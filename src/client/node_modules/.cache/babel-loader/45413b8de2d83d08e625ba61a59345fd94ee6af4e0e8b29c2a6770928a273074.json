{"ast":null,"code":"import { useEffect } from 'react';\nimport isVisible from \"./isVisible\";\nimport useId from \"../hooks/useId\";\nfunction focusable(node) {\n  let includePositive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (isVisible(node)) {\n    const nodeName = node.nodeName.toLowerCase();\n    const isFocusableElement =\n    // Focusable element\n    ['input', 'select', 'textarea', 'button'].includes(nodeName) ||\n    // Editable element\n    node.isContentEditable ||\n    // Anchor with href element\n    nodeName === 'a' && !!node.getAttribute('href');\n\n    // Get tabIndex\n    const tabIndexAttr = node.getAttribute('tabindex');\n    const tabIndexNum = Number(tabIndexAttr);\n\n    // Parse as number if validate\n    let tabIndex = null;\n    if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {\n      tabIndex = tabIndexNum;\n    } else if (isFocusableElement && tabIndex === null) {\n      tabIndex = 0;\n    }\n\n    // Block focusable if disabled\n    if (isFocusableElement && node.disabled) {\n      tabIndex = null;\n    }\n    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);\n  }\n  return false;\n}\nexport function getFocusNodeList(node) {\n  let includePositive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const res = [...node.querySelectorAll('*')].filter(child => {\n    return focusable(child, includePositive);\n  });\n  if (focusable(node, includePositive)) {\n    res.unshift(node);\n  }\n  return res;\n}\n// Used for `rc-input` `rc-textarea` `rc-input-number`\n/**\n * Focus element and set cursor position for input/textarea elements.\n */\nexport function triggerFocus(element, option) {\n  if (!element) return;\n  element.focus(option);\n\n  // Selection content\n  const {\n    cursor\n  } = option || {};\n  if (cursor && (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement)) {\n    const len = element.value.length;\n    switch (cursor) {\n      case 'start':\n        element.setSelectionRange(0, 0);\n        break;\n      case 'end':\n        element.setSelectionRange(len, len);\n        break;\n      default:\n        element.setSelectionRange(0, len);\n    }\n  }\n}\n\n// ======================================================\n// ==                    Lock Focus                    ==\n// ======================================================\nlet lastFocusElement = null;\nlet focusElements = [];\n// Map stable ID to lock element\nconst idToElementMap = new Map();\n// Map stable ID to ignored element\nconst ignoredElementMap = new Map();\nfunction getLastElement() {\n  return focusElements[focusElements.length - 1];\n}\nfunction isIgnoredElement(element) {\n  const lastElement = getLastElement();\n  if (element && lastElement) {\n    // Find the ID that maps to the last element\n    let lockId;\n    for (const [id, ele] of idToElementMap.entries()) {\n      if (ele === lastElement) {\n        lockId = id;\n        break;\n      }\n    }\n    const ignoredEle = ignoredElementMap.get(lockId);\n    return !!ignoredEle && (ignoredEle === element || ignoredEle.contains(element));\n  }\n  return false;\n}\nfunction hasFocus(element) {\n  const {\n    activeElement\n  } = document;\n  return element === activeElement || element.contains(activeElement);\n}\nfunction syncFocus() {\n  const lastElement = getLastElement();\n  const {\n    activeElement\n  } = document;\n\n  // If current focus is on an ignored element, don't force it back\n  if (isIgnoredElement(activeElement)) {\n    return;\n  }\n  if (lastElement && !hasFocus(lastElement)) {\n    const focusableList = getFocusNodeList(lastElement);\n    const matchElement = focusableList.includes(lastFocusElement) ? lastFocusElement : focusableList[0];\n    matchElement === null || matchElement === void 0 || matchElement.focus({\n      preventScroll: true\n    });\n  } else {\n    lastFocusElement = activeElement;\n  }\n}\nfunction onWindowKeyDown(e) {\n  if (e.key === 'Tab') {\n    const {\n      activeElement\n    } = document;\n    const lastElement = getLastElement();\n    const focusableList = getFocusNodeList(lastElement);\n    const last = focusableList[focusableList.length - 1];\n    if (e.shiftKey && activeElement === focusableList[0]) {\n      // Tab backward on first focusable element\n      lastFocusElement = last;\n    } else if (!e.shiftKey && activeElement === last) {\n      // Tab forward on last focusable element\n      lastFocusElement = focusableList[0];\n    }\n  }\n}\n\n/**\n * Lock focus in the element.\n * It will force back to the first focusable element when focus leaves the element.\n * @param id - A stable ID for this lock instance\n */\nexport function lockFocus(element, id) {\n  if (element) {\n    // Store the mapping between ID and element\n    idToElementMap.set(id, element);\n\n    // Refresh focus elements\n    focusElements = focusElements.filter(ele => ele !== element);\n    focusElements.push(element);\n\n    // Just add event since it will de-duplicate\n    window.addEventListener('focusin', syncFocus);\n    window.addEventListener('keydown', onWindowKeyDown, true);\n    syncFocus();\n  }\n\n  // Always return unregister function\n  return () => {\n    lastFocusElement = null;\n    focusElements = focusElements.filter(ele => ele !== element);\n    idToElementMap.delete(id);\n    ignoredElementMap.delete(id);\n    if (focusElements.length === 0) {\n      window.removeEventListener('focusin', syncFocus);\n      window.removeEventListener('keydown', onWindowKeyDown, true);\n    }\n  };\n}\n\n/**\n * Lock focus within an element.\n * When locked, focus will be restricted to focusable elements within the specified element.\n * If multiple elements are locked, only the last locked element will be effective.\n * @returns A function to mark an element as ignored, which will temporarily allow focus on that element even if it's outside the locked area.\n */\nexport function useLockFocus(lock, getElement) {\n  const id = useId();\n  useEffect(() => {\n    if (lock) {\n      const element = getElement();\n      if (element) {\n        return lockFocus(element, id);\n      }\n    }\n  }, [lock, id]);\n  const ignoreElement = ele => {\n    if (ele) {\n      // Set the ignored element using stable ID\n      ignoredElementMap.set(id, ele);\n    }\n  };\n  return [ignoreElement];\n}","map":{"version":3,"names":["useEffect","isVisible","useId","focusable","node","includePositive","arguments","length","undefined","nodeName","toLowerCase","isFocusableElement","includes","isContentEditable","getAttribute","tabIndexAttr","tabIndexNum","Number","tabIndex","isNaN","disabled","getFocusNodeList","res","querySelectorAll","filter","child","unshift","triggerFocus","element","option","focus","cursor","HTMLInputElement","HTMLTextAreaElement","len","value","setSelectionRange","lastFocusElement","focusElements","idToElementMap","Map","ignoredElementMap","getLastElement","isIgnoredElement","lastElement","lockId","id","ele","entries","ignoredEle","get","contains","hasFocus","activeElement","document","syncFocus","focusableList","matchElement","preventScroll","onWindowKeyDown","e","key","last","shiftKey","lockFocus","set","push","window","addEventListener","delete","removeEventListener","useLockFocus","lock","getElement","ignoreElement"],"sources":["/Users/ferncliffadmin/clawd/projects/thesalessherpa/src/client/node_modules/@rc-component/util/es/Dom/focus.js"],"sourcesContent":["import { useEffect } from 'react';\nimport isVisible from \"./isVisible\";\nimport useId from \"../hooks/useId\";\nfunction focusable(node, includePositive = false) {\n  if (isVisible(node)) {\n    const nodeName = node.nodeName.toLowerCase();\n    const isFocusableElement =\n    // Focusable element\n    ['input', 'select', 'textarea', 'button'].includes(nodeName) ||\n    // Editable element\n    node.isContentEditable ||\n    // Anchor with href element\n    nodeName === 'a' && !!node.getAttribute('href');\n\n    // Get tabIndex\n    const tabIndexAttr = node.getAttribute('tabindex');\n    const tabIndexNum = Number(tabIndexAttr);\n\n    // Parse as number if validate\n    let tabIndex = null;\n    if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {\n      tabIndex = tabIndexNum;\n    } else if (isFocusableElement && tabIndex === null) {\n      tabIndex = 0;\n    }\n\n    // Block focusable if disabled\n    if (isFocusableElement && node.disabled) {\n      tabIndex = null;\n    }\n    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);\n  }\n  return false;\n}\nexport function getFocusNodeList(node, includePositive = false) {\n  const res = [...node.querySelectorAll('*')].filter(child => {\n    return focusable(child, includePositive);\n  });\n  if (focusable(node, includePositive)) {\n    res.unshift(node);\n  }\n  return res;\n}\n// Used for `rc-input` `rc-textarea` `rc-input-number`\n/**\n * Focus element and set cursor position for input/textarea elements.\n */\nexport function triggerFocus(element, option) {\n  if (!element) return;\n  element.focus(option);\n\n  // Selection content\n  const {\n    cursor\n  } = option || {};\n  if (cursor && (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement)) {\n    const len = element.value.length;\n    switch (cursor) {\n      case 'start':\n        element.setSelectionRange(0, 0);\n        break;\n      case 'end':\n        element.setSelectionRange(len, len);\n        break;\n      default:\n        element.setSelectionRange(0, len);\n    }\n  }\n}\n\n// ======================================================\n// ==                    Lock Focus                    ==\n// ======================================================\nlet lastFocusElement = null;\nlet focusElements = [];\n// Map stable ID to lock element\nconst idToElementMap = new Map();\n// Map stable ID to ignored element\nconst ignoredElementMap = new Map();\nfunction getLastElement() {\n  return focusElements[focusElements.length - 1];\n}\nfunction isIgnoredElement(element) {\n  const lastElement = getLastElement();\n  if (element && lastElement) {\n    // Find the ID that maps to the last element\n    let lockId;\n    for (const [id, ele] of idToElementMap.entries()) {\n      if (ele === lastElement) {\n        lockId = id;\n        break;\n      }\n    }\n    const ignoredEle = ignoredElementMap.get(lockId);\n    return !!ignoredEle && (ignoredEle === element || ignoredEle.contains(element));\n  }\n  return false;\n}\nfunction hasFocus(element) {\n  const {\n    activeElement\n  } = document;\n  return element === activeElement || element.contains(activeElement);\n}\nfunction syncFocus() {\n  const lastElement = getLastElement();\n  const {\n    activeElement\n  } = document;\n\n  // If current focus is on an ignored element, don't force it back\n  if (isIgnoredElement(activeElement)) {\n    return;\n  }\n  if (lastElement && !hasFocus(lastElement)) {\n    const focusableList = getFocusNodeList(lastElement);\n    const matchElement = focusableList.includes(lastFocusElement) ? lastFocusElement : focusableList[0];\n    matchElement?.focus({\n      preventScroll: true\n    });\n  } else {\n    lastFocusElement = activeElement;\n  }\n}\nfunction onWindowKeyDown(e) {\n  if (e.key === 'Tab') {\n    const {\n      activeElement\n    } = document;\n    const lastElement = getLastElement();\n    const focusableList = getFocusNodeList(lastElement);\n    const last = focusableList[focusableList.length - 1];\n    if (e.shiftKey && activeElement === focusableList[0]) {\n      // Tab backward on first focusable element\n      lastFocusElement = last;\n    } else if (!e.shiftKey && activeElement === last) {\n      // Tab forward on last focusable element\n      lastFocusElement = focusableList[0];\n    }\n  }\n}\n\n/**\n * Lock focus in the element.\n * It will force back to the first focusable element when focus leaves the element.\n * @param id - A stable ID for this lock instance\n */\nexport function lockFocus(element, id) {\n  if (element) {\n    // Store the mapping between ID and element\n    idToElementMap.set(id, element);\n\n    // Refresh focus elements\n    focusElements = focusElements.filter(ele => ele !== element);\n    focusElements.push(element);\n\n    // Just add event since it will de-duplicate\n    window.addEventListener('focusin', syncFocus);\n    window.addEventListener('keydown', onWindowKeyDown, true);\n    syncFocus();\n  }\n\n  // Always return unregister function\n  return () => {\n    lastFocusElement = null;\n    focusElements = focusElements.filter(ele => ele !== element);\n    idToElementMap.delete(id);\n    ignoredElementMap.delete(id);\n    if (focusElements.length === 0) {\n      window.removeEventListener('focusin', syncFocus);\n      window.removeEventListener('keydown', onWindowKeyDown, true);\n    }\n  };\n}\n\n/**\n * Lock focus within an element.\n * When locked, focus will be restricted to focusable elements within the specified element.\n * If multiple elements are locked, only the last locked element will be effective.\n * @returns A function to mark an element as ignored, which will temporarily allow focus on that element even if it's outside the locked area.\n */\nexport function useLockFocus(lock, getElement) {\n  const id = useId();\n  useEffect(() => {\n    if (lock) {\n      const element = getElement();\n      if (element) {\n        return lockFocus(element, id);\n      }\n    }\n  }, [lock, id]);\n  const ignoreElement = ele => {\n    if (ele) {\n      // Set the ignored element using stable ID\n      ignoredElementMap.set(id, ele);\n    }\n  };\n  return [ignoreElement];\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}