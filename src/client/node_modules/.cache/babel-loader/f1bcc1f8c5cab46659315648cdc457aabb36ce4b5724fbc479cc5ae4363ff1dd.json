{"ast":null,"code":"import _objectSpread from \"/Users/ferncliffadmin/clawd/projects/thesalessherpa/src/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/Users/ferncliffadmin/clawd/projects/thesalessherpa/src/client/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n// TODO: Fully accessibility support\n// Reference: https://www.w3.org/WAI/ARIA/apg/patterns/treeview\n\nimport { clsx } from 'clsx';\nimport pickAttrs from \"@rc-component/util/es/pickAttrs\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { TreeContext } from \"./contextTypes\";\nimport DropIndicator from \"./DropIndicator\";\nimport NodeList, { MOTION_KEY, MotionEntity } from \"./NodeList\";\nimport TreeNode from \"./TreeNode\";\nimport { arrAdd, arrDel, calcDropPosition, calcSelectedKeys, conductExpandParent, getDragChildrenKeys, parseCheckedKeys, posToArr } from \"./util\";\nimport { conductCheck } from \"./utils/conductUtil\";\nimport getEntity from \"./utils/keyUtil\";\nimport { convertDataToEntities, convertNodePropsToEventData, convertTreeToData, fillFieldNames, flattenTreeData, getTreeNodeProps, isLeafNode, warningWithoutKey } from \"./utils/treeUtil\";\nconst MAX_RETRY_TIMES = 10;\nclass Tree extends React.Component {\n  constructor() {\n    var _this;\n    super(...arguments);\n    _this = this;\n    _defineProperty(this, \"destroyed\", false);\n    _defineProperty(this, \"delayedDragEnterLogic\", void 0);\n    _defineProperty(this, \"loadingRetryTimes\", {});\n    _defineProperty(this, \"state\", {\n      keyEntities: {},\n      indent: null,\n      selectedKeys: [],\n      checkedKeys: [],\n      halfCheckedKeys: [],\n      loadedKeys: [],\n      loadingKeys: [],\n      expandedKeys: [],\n      draggingNodeKey: null,\n      dragChildrenKeys: [],\n      // dropTargetKey is the key of abstract-drop-node\n      // the abstract-drop-node is the real drop node when drag and drop\n      // not the DOM drag over node\n      dropTargetKey: null,\n      dropPosition: null,\n      // the drop position of abstract-drop-node, inside 0, top -1, bottom 1\n      dropContainerKey: null,\n      // the container key of abstract-drop-node if dropPosition is -1 or 1\n      dropLevelOffset: null,\n      // the drop level offset of abstract-drag-over-node\n      dropTargetPos: null,\n      // the pos of abstract-drop-node\n      dropAllowed: true,\n      // if drop to abstract-drop-node is allowed\n      // the abstract-drag-over-node\n      // if mouse is on the bottom of top dom node or no the top of the bottom dom node\n      // abstract-drag-over-node is the top node\n      dragOverNodeKey: null,\n      treeData: [],\n      flattenNodes: [],\n      activeKey: null,\n      listChanging: false,\n      prevProps: null,\n      fieldNames: fillFieldNames()\n    });\n    _defineProperty(this, \"dragStartMousePosition\", null);\n    _defineProperty(this, \"dragNodeProps\", null);\n    _defineProperty(this, \"currentMouseOverDroppableNodeKey\", null);\n    _defineProperty(this, \"listRef\", /*#__PURE__*/React.createRef());\n    _defineProperty(this, \"onNodeDragStart\", (event, nodeProps) => {\n      const {\n        expandedKeys,\n        keyEntities\n      } = this.state;\n      const {\n        onDragStart\n      } = this.props;\n      const {\n        eventKey\n      } = nodeProps;\n      this.dragNodeProps = nodeProps;\n      this.dragStartMousePosition = {\n        x: event.clientX,\n        y: event.clientY\n      };\n      const newExpandedKeys = arrDel(expandedKeys, eventKey);\n      this.setState({\n        draggingNodeKey: eventKey,\n        dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),\n        indent: this.listRef.current.getIndentWidth()\n      });\n      this.setExpandedKeys(newExpandedKeys);\n      window.addEventListener('dragend', this.onWindowDragEnd);\n      onDragStart === null || onDragStart === void 0 || onDragStart({\n        event,\n        node: convertNodePropsToEventData(nodeProps)\n      });\n    });\n    /**\n     * [Legacy] Select handler is smaller than node,\n     * so that this will trigger when drag enter node or select handler.\n     * This is a little tricky if customize css without padding.\n     * Better for use mouse move event to refresh drag state.\n     * But let's just keep it to avoid event trigger logic change.\n     */\n    _defineProperty(this, \"onNodeDragEnter\", (event, nodeProps) => {\n      const {\n        expandedKeys,\n        keyEntities,\n        dragChildrenKeys,\n        flattenNodes,\n        indent\n      } = this.state;\n      const {\n        onDragEnter,\n        onExpand,\n        allowDrop,\n        direction\n      } = this.props;\n      const {\n        pos,\n        eventKey\n      } = nodeProps;\n\n      // record the key of node which is latest entered, used in dragleave event.\n      if (this.currentMouseOverDroppableNodeKey !== eventKey) {\n        this.currentMouseOverDroppableNodeKey = eventKey;\n      }\n      if (!this.dragNodeProps) {\n        this.resetDragState();\n        return;\n      }\n      const {\n        dropPosition,\n        dropLevelOffset,\n        dropTargetKey,\n        dropContainerKey,\n        dropTargetPos,\n        dropAllowed,\n        dragOverNodeKey\n      } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);\n      if (\n      // don't allow drop inside its children\n      dragChildrenKeys.includes(dropTargetKey) ||\n      // don't allow drop when drop is not allowed caculated by calcDropPosition\n      !dropAllowed) {\n        this.resetDragState();\n        return;\n      }\n\n      // Side effect for delay drag\n      if (!this.delayedDragEnterLogic) {\n        this.delayedDragEnterLogic = {};\n      }\n      Object.keys(this.delayedDragEnterLogic).forEach(key => {\n        clearTimeout(this.delayedDragEnterLogic[key]);\n      });\n      if (this.dragNodeProps.eventKey !== nodeProps.eventKey) {\n        // hoist expand logic here\n        // since if logic is on the bottom\n        // it will be blocked by abstract dragover node check\n        //   => if you dragenter from top, you mouse will still be consider as in the top node\n        event.persist();\n        this.delayedDragEnterLogic[pos] = window.setTimeout(() => {\n          if (this.state.draggingNodeKey === null) {\n            return;\n          }\n          let newExpandedKeys = [...expandedKeys];\n          const entity = getEntity(keyEntities, nodeProps.eventKey);\n          if (entity && (entity.children || []).length) {\n            newExpandedKeys = arrAdd(expandedKeys, nodeProps.eventKey);\n          }\n          if (!this.props.hasOwnProperty('expandedKeys')) {\n            this.setExpandedKeys(newExpandedKeys);\n          }\n          onExpand === null || onExpand === void 0 || onExpand(newExpandedKeys, {\n            node: convertNodePropsToEventData(nodeProps),\n            expanded: true,\n            nativeEvent: event.nativeEvent\n          });\n        }, 800);\n      }\n\n      // Skip if drag node is self\n      if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {\n        this.resetDragState();\n        return;\n      }\n\n      // Update drag over node and drag state\n      this.setState({\n        dragOverNodeKey,\n        dropPosition,\n        dropLevelOffset,\n        dropTargetKey,\n        dropContainerKey,\n        dropTargetPos,\n        dropAllowed\n      });\n      onDragEnter === null || onDragEnter === void 0 || onDragEnter({\n        event,\n        node: convertNodePropsToEventData(nodeProps),\n        expandedKeys\n      });\n    });\n    _defineProperty(this, \"onNodeDragOver\", (event, nodeProps) => {\n      const {\n        dragChildrenKeys,\n        flattenNodes,\n        keyEntities,\n        expandedKeys,\n        indent\n      } = this.state;\n      const {\n        onDragOver,\n        allowDrop,\n        direction\n      } = this.props;\n      if (!this.dragNodeProps) {\n        return;\n      }\n      const {\n        dropPosition,\n        dropLevelOffset,\n        dropTargetKey,\n        dropContainerKey,\n        dropTargetPos,\n        dropAllowed,\n        dragOverNodeKey\n      } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);\n      if (dragChildrenKeys.includes(dropTargetKey) || !dropAllowed) {\n        // don't allow drop inside its children\n        // don't allow drop when drop is not allowed calculated by calcDropPosition\n        return;\n      }\n\n      // Update drag position\n\n      if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {\n        if (!(this.state.dropPosition === null && this.state.dropLevelOffset === null && this.state.dropTargetKey === null && this.state.dropContainerKey === null && this.state.dropTargetPos === null && this.state.dropAllowed === false && this.state.dragOverNodeKey === null)) {\n          this.resetDragState();\n        }\n      } else if (!(dropPosition === this.state.dropPosition && dropLevelOffset === this.state.dropLevelOffset && dropTargetKey === this.state.dropTargetKey && dropContainerKey === this.state.dropContainerKey && dropTargetPos === this.state.dropTargetPos && dropAllowed === this.state.dropAllowed && dragOverNodeKey === this.state.dragOverNodeKey)) {\n        this.setState({\n          dropPosition,\n          dropLevelOffset,\n          dropTargetKey,\n          dropContainerKey,\n          dropTargetPos,\n          dropAllowed,\n          dragOverNodeKey\n        });\n      }\n      onDragOver === null || onDragOver === void 0 || onDragOver({\n        event,\n        node: convertNodePropsToEventData(nodeProps)\n      });\n    });\n    _defineProperty(this, \"onNodeDragLeave\", (event, nodeProps) => {\n      // if it is outside the droppable area\n      // currentMouseOverDroppableNodeKey will be updated in dragenter event when into another droppable receiver.\n      if (this.currentMouseOverDroppableNodeKey === nodeProps.eventKey && !event.currentTarget.contains(event.relatedTarget)) {\n        this.resetDragState();\n        this.currentMouseOverDroppableNodeKey = null;\n      }\n      const {\n        onDragLeave\n      } = this.props;\n      onDragLeave === null || onDragLeave === void 0 || onDragLeave({\n        event,\n        node: convertNodePropsToEventData(nodeProps)\n      });\n    });\n    // since stopPropagation() is called in treeNode\n    // if onWindowDrag is called, whice means state is keeped, drag state should be cleared\n    _defineProperty(this, \"onWindowDragEnd\", event => {\n      this.onNodeDragEnd(event, null, true);\n      window.removeEventListener('dragend', this.onWindowDragEnd);\n    });\n    // if onNodeDragEnd is called, onWindowDragEnd won't be called since stopPropagation() is called\n    _defineProperty(this, \"onNodeDragEnd\", (event, nodeProps) => {\n      const {\n        onDragEnd\n      } = this.props;\n      this.setState({\n        dragOverNodeKey: null\n      });\n      this.cleanDragState();\n      onDragEnd === null || onDragEnd === void 0 || onDragEnd({\n        event,\n        node: convertNodePropsToEventData(nodeProps)\n      });\n      this.dragNodeProps = null;\n      window.removeEventListener('dragend', this.onWindowDragEnd);\n    });\n    _defineProperty(this, \"onNodeDrop\", function (event, _) {\n      var _this$getActiveItem;\n      let outsideTree = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      const {\n        dragChildrenKeys,\n        dropPosition,\n        dropTargetKey,\n        dropTargetPos,\n        dropAllowed\n      } = _this.state;\n      if (!dropAllowed) {\n        return;\n      }\n      const {\n        onDrop\n      } = _this.props;\n      _this.setState({\n        dragOverNodeKey: null\n      });\n      _this.cleanDragState();\n      if (dropTargetKey === null) return;\n      const abstractDropNodeProps = _objectSpread(_objectSpread({}, getTreeNodeProps(dropTargetKey, _this.getTreeNodeRequiredProps())), {}, {\n        active: ((_this$getActiveItem = _this.getActiveItem()) === null || _this$getActiveItem === void 0 ? void 0 : _this$getActiveItem.key) === dropTargetKey,\n        data: getEntity(_this.state.keyEntities, dropTargetKey).node\n      });\n      const dropToChild = dragChildrenKeys.includes(dropTargetKey);\n      warning(!dropToChild, \"Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.\");\n      const posArr = posToArr(dropTargetPos);\n      const dropResult = {\n        event,\n        node: convertNodePropsToEventData(abstractDropNodeProps),\n        dragNode: _this.dragNodeProps ? convertNodePropsToEventData(_this.dragNodeProps) : null,\n        dragNodesKeys: [_this.dragNodeProps.eventKey].concat(dragChildrenKeys),\n        dropToGap: dropPosition !== 0,\n        dropPosition: dropPosition + Number(posArr[posArr.length - 1])\n      };\n      if (!outsideTree) {\n        onDrop === null || onDrop === void 0 || onDrop(dropResult);\n      }\n      _this.dragNodeProps = null;\n    });\n    _defineProperty(this, \"cleanDragState\", () => {\n      const {\n        draggingNodeKey\n      } = this.state;\n      if (draggingNodeKey !== null) {\n        this.setState({\n          draggingNodeKey: null,\n          dropPosition: null,\n          dropContainerKey: null,\n          dropTargetKey: null,\n          dropLevelOffset: null,\n          dropAllowed: true,\n          dragOverNodeKey: null\n        });\n      }\n      this.dragStartMousePosition = null;\n      this.currentMouseOverDroppableNodeKey = null;\n    });\n    _defineProperty(this, \"triggerExpandActionExpand\", (e, treeNode) => {\n      const {\n        expandedKeys,\n        flattenNodes\n      } = this.state;\n      const {\n        expanded,\n        key,\n        isLeaf\n      } = treeNode;\n      if (isLeaf || e.shiftKey || e.metaKey || e.ctrlKey) {\n        return;\n      }\n      const node = flattenNodes.filter(nodeItem => nodeItem.key === key)[0];\n      const eventNode = convertNodePropsToEventData(_objectSpread(_objectSpread({}, getTreeNodeProps(key, this.getTreeNodeRequiredProps())), {}, {\n        data: node.data\n      }));\n      this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));\n      this.onNodeExpand(e, eventNode);\n    });\n    _defineProperty(this, \"onNodeClick\", (e, treeNode) => {\n      const {\n        onClick,\n        expandAction\n      } = this.props;\n      if (expandAction === 'click') {\n        this.triggerExpandActionExpand(e, treeNode);\n      }\n      onClick === null || onClick === void 0 || onClick(e, treeNode);\n    });\n    _defineProperty(this, \"onNodeDoubleClick\", (e, treeNode) => {\n      const {\n        onDoubleClick,\n        expandAction\n      } = this.props;\n      if (expandAction === 'doubleClick') {\n        this.triggerExpandActionExpand(e, treeNode);\n      }\n      onDoubleClick === null || onDoubleClick === void 0 || onDoubleClick(e, treeNode);\n    });\n    _defineProperty(this, \"onNodeSelect\", (e, treeNode) => {\n      let {\n        selectedKeys\n      } = this.state;\n      const {\n        keyEntities,\n        fieldNames\n      } = this.state;\n      const {\n        onSelect,\n        multiple\n      } = this.props;\n      const {\n        selected\n      } = treeNode;\n      const key = treeNode[fieldNames.key];\n      const targetSelected = !selected;\n\n      // Update selected keys\n      if (!targetSelected) {\n        selectedKeys = arrDel(selectedKeys, key);\n      } else if (!multiple) {\n        selectedKeys = [key];\n      } else {\n        selectedKeys = arrAdd(selectedKeys, key);\n      }\n\n      // [Legacy] Not found related usage in doc or upper libs\n      const selectedNodes = selectedKeys.map(selectedKey => {\n        const entity = getEntity(keyEntities, selectedKey);\n        return entity ? entity.node : null;\n      }).filter(Boolean);\n      this.setUncontrolledState({\n        selectedKeys\n      });\n      onSelect === null || onSelect === void 0 || onSelect(selectedKeys, {\n        event: 'select',\n        selected: targetSelected,\n        node: treeNode,\n        selectedNodes,\n        nativeEvent: e.nativeEvent\n      });\n    });\n    _defineProperty(this, \"onNodeCheck\", (e, treeNode, checked) => {\n      const {\n        keyEntities,\n        checkedKeys: oriCheckedKeys,\n        halfCheckedKeys: oriHalfCheckedKeys\n      } = this.state;\n      const {\n        checkStrictly,\n        onCheck\n      } = this.props;\n      const {\n        key\n      } = treeNode;\n\n      // Prepare trigger arguments\n      let checkedObj;\n      const eventObj = {\n        event: 'check',\n        node: treeNode,\n        checked,\n        nativeEvent: e.nativeEvent\n      };\n      if (checkStrictly) {\n        const checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);\n        const halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);\n        checkedObj = {\n          checked: checkedKeys,\n          halfChecked: halfCheckedKeys\n        };\n        eventObj.checkedNodes = checkedKeys.map(checkedKey => getEntity(keyEntities, checkedKey)).filter(Boolean).map(entity => entity.node);\n        this.setUncontrolledState({\n          checkedKeys\n        });\n      } else {\n        // Always fill first\n        let {\n          checkedKeys,\n          halfCheckedKeys\n        } = conductCheck([...oriCheckedKeys, key], true, keyEntities);\n\n        // If remove, we do it again to correction\n        if (!checked) {\n          const keySet = new Set(checkedKeys);\n          keySet.delete(key);\n          ({\n            checkedKeys,\n            halfCheckedKeys\n          } = conductCheck(Array.from(keySet), {\n            checked: false,\n            halfCheckedKeys\n          }, keyEntities));\n        }\n        checkedObj = checkedKeys;\n\n        // [Legacy] This is used for `rc-tree-select`\n        eventObj.checkedNodes = [];\n        eventObj.checkedNodesPositions = [];\n        eventObj.halfCheckedKeys = halfCheckedKeys;\n        checkedKeys.forEach(checkedKey => {\n          const entity = getEntity(keyEntities, checkedKey);\n          if (!entity) return;\n          const {\n            node,\n            pos\n          } = entity;\n          eventObj.checkedNodes.push(node);\n          eventObj.checkedNodesPositions.push({\n            node,\n            pos\n          });\n        });\n        this.setUncontrolledState({\n          checkedKeys\n        }, false, {\n          halfCheckedKeys\n        });\n      }\n      onCheck === null || onCheck === void 0 || onCheck(checkedObj, eventObj);\n    });\n    _defineProperty(this, \"onNodeLoad\", treeNode => {\n      var _entity$children;\n      const {\n        key\n      } = treeNode;\n      const {\n        keyEntities\n      } = this.state;\n\n      // Skip if has children already\n      const entity = getEntity(keyEntities, key);\n      if (entity !== null && entity !== void 0 && (_entity$children = entity.children) !== null && _entity$children !== void 0 && _entity$children.length) {\n        return;\n      }\n      const loadPromise = new Promise((resolve, reject) => {\n        // We need to get the latest state of loading/loaded keys\n        this.setState(_ref => {\n          let {\n            loadedKeys = [],\n            loadingKeys = []\n          } = _ref;\n          const {\n            loadData,\n            onLoad\n          } = this.props;\n          if (!loadData || loadedKeys.includes(key) || loadingKeys.includes(key)) {\n            return null;\n          }\n\n          // Process load data\n          const promise = loadData(treeNode);\n          promise.then(() => {\n            const {\n              loadedKeys: currentLoadedKeys\n            } = this.state;\n            const newLoadedKeys = arrAdd(currentLoadedKeys, key);\n\n            // onLoad should trigger before internal setState to avoid `loadData` trigger twice.\n            // https://github.com/ant-design/ant-design/issues/12464\n            onLoad === null || onLoad === void 0 || onLoad(newLoadedKeys, {\n              event: 'load',\n              node: treeNode\n            });\n            this.setUncontrolledState({\n              loadedKeys: newLoadedKeys\n            });\n            this.setState(prevState => ({\n              loadingKeys: arrDel(prevState.loadingKeys, key)\n            }));\n            resolve();\n          }).catch(e => {\n            this.setState(prevState => ({\n              loadingKeys: arrDel(prevState.loadingKeys, key)\n            }));\n\n            // If exceed max retry times, we give up retry\n            this.loadingRetryTimes[key] = (this.loadingRetryTimes[key] || 0) + 1;\n            if (this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {\n              const {\n                loadedKeys: currentLoadedKeys\n              } = this.state;\n              warning(false, 'Retry for `loadData` many times but still failed. No more retry.');\n              this.setUncontrolledState({\n                loadedKeys: arrAdd(currentLoadedKeys, key)\n              });\n              resolve();\n            }\n            reject(e);\n          });\n          return {\n            loadingKeys: arrAdd(loadingKeys, key)\n          };\n        });\n      });\n\n      // Not care warning if we ignore this\n      loadPromise.catch(() => {});\n      return loadPromise;\n    });\n    _defineProperty(this, \"onNodeMouseEnter\", (event, node) => {\n      const {\n        onMouseEnter\n      } = this.props;\n      onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({\n        event,\n        node\n      });\n    });\n    _defineProperty(this, \"onNodeMouseLeave\", (event, node) => {\n      const {\n        onMouseLeave\n      } = this.props;\n      onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave({\n        event,\n        node\n      });\n    });\n    _defineProperty(this, \"onNodeContextMenu\", (event, node) => {\n      const {\n        onRightClick\n      } = this.props;\n      if (onRightClick) {\n        event.preventDefault();\n        onRightClick({\n          event,\n          node\n        });\n      }\n    });\n    _defineProperty(this, \"onFocus\", function () {\n      const {\n        onFocus,\n        disabled\n      } = _this.props;\n      const {\n        activeKey,\n        selectedKeys,\n        flattenNodes\n      } = _this.state;\n      if (!disabled && activeKey === null) {\n        const visibleSelectedKey = selectedKeys.find(key => {\n          return flattenNodes.some(nodeItem => nodeItem.key === key);\n        });\n        if (visibleSelectedKey !== undefined) {\n          _this.onActiveChange(visibleSelectedKey);\n        } else {\n          var _flattenNodes$;\n          _this.onActiveChange((flattenNodes === null || flattenNodes === void 0 || (_flattenNodes$ = flattenNodes[0]) === null || _flattenNodes$ === void 0 ? void 0 : _flattenNodes$.key) || null);\n        }\n      }\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      onFocus === null || onFocus === void 0 || onFocus(...args);\n    });\n    _defineProperty(this, \"onBlur\", function () {\n      const {\n        onBlur\n      } = _this.props;\n      _this.onActiveChange(null);\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      onBlur === null || onBlur === void 0 || onBlur(...args);\n    });\n    _defineProperty(this, \"getTreeNodeRequiredProps\", () => {\n      const {\n        expandedKeys,\n        selectedKeys,\n        loadedKeys,\n        loadingKeys,\n        checkedKeys,\n        halfCheckedKeys,\n        dragOverNodeKey,\n        dropPosition,\n        keyEntities\n      } = this.state;\n      return {\n        expandedKeys: expandedKeys || [],\n        selectedKeys: selectedKeys || [],\n        loadedKeys: loadedKeys || [],\n        loadingKeys: loadingKeys || [],\n        checkedKeys: checkedKeys || [],\n        halfCheckedKeys: halfCheckedKeys || [],\n        dragOverNodeKey,\n        dropPosition,\n        keyEntities: keyEntities\n      };\n    });\n    // =========================== Expanded ===========================\n    /** Set uncontrolled `expandedKeys`. This will also auto update `flattenNodes`. */\n    _defineProperty(this, \"setExpandedKeys\", expandedKeys => {\n      const {\n        treeData,\n        fieldNames\n      } = this.state;\n      const flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);\n      this.setUncontrolledState({\n        expandedKeys,\n        flattenNodes\n      }, true);\n    });\n    _defineProperty(this, \"onNodeExpand\", (e, treeNode) => {\n      let {\n        expandedKeys\n      } = this.state;\n      const {\n        listChanging,\n        fieldNames\n      } = this.state;\n      const {\n        onExpand,\n        loadData\n      } = this.props;\n      const {\n        expanded\n      } = treeNode;\n      const key = treeNode[fieldNames.key];\n\n      // Do nothing when motion is in progress\n      if (listChanging) {\n        return;\n      }\n\n      // Update selected keys\n      const certain = expandedKeys.includes(key);\n      const targetExpanded = !expanded;\n      warning(expanded && certain || !expanded && !certain, 'Expand state not sync with index check');\n      expandedKeys = targetExpanded ? arrAdd(expandedKeys, key) : arrDel(expandedKeys, key);\n      this.setExpandedKeys(expandedKeys);\n      onExpand === null || onExpand === void 0 || onExpand(expandedKeys, {\n        node: treeNode,\n        expanded: targetExpanded,\n        nativeEvent: e.nativeEvent\n      });\n\n      // Async Load data\n      if (targetExpanded && loadData) {\n        const loadPromise = this.onNodeLoad(treeNode);\n        if (loadPromise) {\n          loadPromise.then(() => {\n            // [Legacy] Refresh logic\n            const newFlattenTreeData = flattenTreeData(this.state.treeData, expandedKeys, fieldNames);\n            this.setUncontrolledState({\n              flattenNodes: newFlattenTreeData\n            });\n          }).catch(() => {\n            const {\n              expandedKeys: currentExpandedKeys\n            } = this.state;\n            const expandedKeysToRestore = arrDel(currentExpandedKeys, key);\n            this.setExpandedKeys(expandedKeysToRestore);\n          });\n        }\n      }\n    });\n    _defineProperty(this, \"onListChangeStart\", () => {\n      this.setUncontrolledState({\n        listChanging: true\n      });\n    });\n    _defineProperty(this, \"onListChangeEnd\", () => {\n      setTimeout(() => {\n        this.setUncontrolledState({\n          listChanging: false\n        });\n      });\n    });\n    // =========================== Keyboard ===========================\n    _defineProperty(this, \"onActiveChange\", newActiveKey => {\n      const {\n        activeKey\n      } = this.state;\n      const {\n        onActiveChange,\n        itemScrollOffset = 0\n      } = this.props;\n      if (activeKey === newActiveKey) {\n        return;\n      }\n      this.setState({\n        activeKey: newActiveKey\n      });\n      if (newActiveKey !== null) {\n        this.scrollTo({\n          key: newActiveKey,\n          offset: itemScrollOffset\n        });\n      }\n      onActiveChange === null || onActiveChange === void 0 || onActiveChange(newActiveKey);\n    });\n    _defineProperty(this, \"getActiveItem\", () => {\n      const {\n        activeKey,\n        flattenNodes\n      } = this.state;\n      if (activeKey === null) {\n        return null;\n      }\n      return flattenNodes.find(_ref2 => {\n        let {\n          key\n        } = _ref2;\n        return key === activeKey;\n      }) || null;\n    });\n    _defineProperty(this, \"offsetActiveKey\", offset => {\n      const {\n        flattenNodes,\n        activeKey\n      } = this.state;\n      let index = flattenNodes.findIndex(_ref3 => {\n        let {\n          key\n        } = _ref3;\n        return key === activeKey;\n      });\n\n      // Align with index\n      if (index === -1 && offset < 0) {\n        index = flattenNodes.length;\n      }\n      index = (index + offset + flattenNodes.length) % flattenNodes.length;\n      const item = flattenNodes[index];\n      if (item) {\n        const {\n          key\n        } = item;\n        this.onActiveChange(key);\n      } else {\n        this.onActiveChange(null);\n      }\n    });\n    _defineProperty(this, \"onKeyDown\", event => {\n      const {\n        activeKey,\n        expandedKeys,\n        checkedKeys,\n        flattenNodes,\n        keyEntities\n      } = this.state;\n      const {\n        onKeyDown,\n        checkable,\n        selectable,\n        disabled,\n        loadData\n      } = this.props;\n      if (disabled) {\n        return;\n      }\n\n      // >>>>>>>>>> Direction\n      switch (event.key) {\n        case 'ArrowUp':\n          {\n            this.offsetActiveKey(-1);\n            event.preventDefault();\n            break;\n          }\n        case 'ArrowDown':\n          {\n            this.offsetActiveKey(1);\n            event.preventDefault();\n            break;\n          }\n        case 'Home':\n          {\n            var _flattenNodes$2;\n            this.onActiveChange(flattenNodes === null || flattenNodes === void 0 || (_flattenNodes$2 = flattenNodes[0]) === null || _flattenNodes$2 === void 0 ? void 0 : _flattenNodes$2.key);\n            event.preventDefault();\n            break;\n          }\n        case 'End':\n          {\n            var _flattenNodes;\n            this.onActiveChange(flattenNodes === null || flattenNodes === void 0 || (_flattenNodes = flattenNodes[flattenNodes.length - 1]) === null || _flattenNodes === void 0 ? void 0 : _flattenNodes.key);\n            event.preventDefault();\n            break;\n          }\n      }\n\n      // >>>>>>>>>> Expand & Selection\n      const activeItem = this.getActiveItem();\n      if (activeItem && activeItem.data) {\n        var _entity$children2;\n        const treeNodeRequiredProps = this.getTreeNodeRequiredProps();\n        const eventNode = convertNodePropsToEventData(_objectSpread(_objectSpread({}, getTreeNodeProps(activeKey, treeNodeRequiredProps)), {}, {\n          data: activeItem.data,\n          active: true\n        }));\n        const entity = getEntity(keyEntities, activeKey);\n        const hasChildren = !!(entity !== null && entity !== void 0 && (_entity$children2 = entity.children) !== null && _entity$children2 !== void 0 && _entity$children2.length);\n        const expandable = !isLeafNode(activeItem.data.isLeaf, loadData, hasChildren, eventNode.loaded);\n        const canCheck = checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox;\n        const canSelect = !checkable && selectable && !eventNode.disabled && eventNode.selectable !== false;\n        switch (event.key) {\n          // >>> Expand\n          case 'ArrowLeft':\n            {\n              // Collapse if possible\n              if (expandable && expandedKeys.includes(activeKey)) {\n                this.onNodeExpand({}, eventNode);\n              } else if (activeItem.parent) {\n                this.onActiveChange(activeItem.parent.key);\n              }\n              event.preventDefault();\n              break;\n            }\n          case 'ArrowRight':\n            {\n              // Expand if possible\n              if (expandable && !expandedKeys.includes(activeKey)) {\n                this.onNodeExpand({}, eventNode);\n              } else if (activeItem.children && activeItem.children.length) {\n                this.onActiveChange(activeItem.children[0].key);\n              }\n              event.preventDefault();\n              break;\n            }\n          case 'Enter':\n            {\n              if (expandable) {\n                event.preventDefault();\n                this.onNodeExpand({}, eventNode);\n              } else if (canCheck) {\n                if (!checkedKeys.includes(activeKey)) {\n                  event.preventDefault();\n                  this.onNodeCheck({}, eventNode, true);\n                }\n              } else if (canSelect && !eventNode.selected) {\n                event.preventDefault();\n                this.onNodeSelect({}, eventNode);\n              }\n              break;\n            }\n          case ' ':\n            {\n              if (canCheck) {\n                event.preventDefault();\n                this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));\n              } else if (canSelect) {\n                event.preventDefault();\n                this.onNodeSelect({}, eventNode);\n              }\n              break;\n            }\n        }\n      }\n      onKeyDown === null || onKeyDown === void 0 || onKeyDown(event);\n    });\n    /**\n     * Only update the value which is not in props\n     */\n    _defineProperty(this, \"setUncontrolledState\", function (state) {\n      let atomic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      let forceState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      if (!_this.destroyed) {\n        let needSync = false;\n        let allPassed = true;\n        const newState = {};\n        Object.keys(state).forEach(name => {\n          if (_this.props.hasOwnProperty(name)) {\n            allPassed = false;\n            return;\n          }\n          needSync = true;\n          newState[name] = state[name];\n        });\n        if (needSync && (!atomic || allPassed)) {\n          _this.setState(_objectSpread(_objectSpread({}, newState), forceState));\n        }\n      }\n    });\n    _defineProperty(this, \"scrollTo\", scroll => {\n      this.listRef.current.scrollTo(scroll);\n    });\n  }\n  componentDidMount() {\n    this.destroyed = false;\n    this.onUpdated();\n  }\n  componentDidUpdate() {\n    this.onUpdated();\n  }\n  onUpdated() {\n    const {\n      activeKey,\n      itemScrollOffset = 0\n    } = this.props;\n    if (activeKey !== undefined && activeKey !== this.state.activeKey) {\n      this.setState({\n        activeKey\n      });\n      if (activeKey !== null) {\n        this.scrollTo({\n          key: activeKey,\n          offset: itemScrollOffset\n        });\n      }\n    }\n  }\n  componentWillUnmount() {\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n    this.destroyed = true;\n  }\n  static getDerivedStateFromProps(props, prevState) {\n    const {\n      prevProps\n    } = prevState;\n    const newState = {\n      prevProps: props\n    };\n    function needSync(name) {\n      return !prevProps && props.hasOwnProperty(name) || prevProps && prevProps[name] !== props[name];\n    }\n\n    // ================== Tree Node ==================\n    let treeData;\n\n    // fieldNames\n    let {\n      fieldNames\n    } = prevState;\n    if (needSync('fieldNames')) {\n      fieldNames = fillFieldNames(props.fieldNames);\n      newState.fieldNames = fieldNames;\n    }\n\n    // Check if `treeData` or `children` changed and save into the state.\n    if (needSync('treeData')) {\n      ({\n        treeData\n      } = props);\n    } else if (needSync('children')) {\n      warning(false, '`children` of Tree is deprecated. Please use `treeData` instead.');\n      treeData = convertTreeToData(props.children);\n    }\n\n    // Save flatten nodes info and convert `treeData` into keyEntities\n    if (treeData) {\n      newState.treeData = treeData;\n      const entitiesMap = convertDataToEntities(treeData, {\n        fieldNames\n      });\n      newState.keyEntities = _objectSpread({\n        [MOTION_KEY]: MotionEntity\n      }, entitiesMap.keyEntities);\n\n      // Warning if treeNode not provide key\n      if (process.env.NODE_ENV !== 'production') {\n        warningWithoutKey(treeData, fieldNames);\n      }\n    }\n    const keyEntities = newState.keyEntities || prevState.keyEntities;\n\n    // ================ expandedKeys =================\n    if (needSync('expandedKeys') || prevProps && needSync('autoExpandParent')) {\n      newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;\n    } else if (!prevProps && props.defaultExpandAll) {\n      const cloneKeyEntities = _objectSpread({}, keyEntities);\n      delete cloneKeyEntities[MOTION_KEY];\n\n      // Only take the key who has the children to enhance the performance\n      const nextExpandedKeys = [];\n      Object.keys(cloneKeyEntities).forEach(key => {\n        const entity = cloneKeyEntities[key];\n        if (entity.children && entity.children.length) {\n          nextExpandedKeys.push(entity.key);\n        }\n      });\n      newState.expandedKeys = nextExpandedKeys;\n    } else if (!prevProps && props.defaultExpandedKeys) {\n      newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;\n    }\n    if (!newState.expandedKeys) {\n      delete newState.expandedKeys;\n    }\n\n    // ================ flattenNodes =================\n    if (treeData || newState.expandedKeys) {\n      const flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);\n      newState.flattenNodes = flattenNodes;\n    }\n\n    // ================ selectedKeys =================\n    if (props.selectable) {\n      if (needSync('selectedKeys')) {\n        newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);\n      } else if (!prevProps && props.defaultSelectedKeys) {\n        newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);\n      }\n    }\n\n    // ================= checkedKeys =================\n    if (props.checkable) {\n      let checkedKeyEntity;\n      if (needSync('checkedKeys')) {\n        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};\n      } else if (!prevProps && props.defaultCheckedKeys) {\n        checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};\n      } else if (treeData) {\n        // If `treeData` changed, we also need check it\n        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {\n          checkedKeys: prevState.checkedKeys,\n          halfCheckedKeys: prevState.halfCheckedKeys\n        };\n      }\n      if (checkedKeyEntity) {\n        let {\n          checkedKeys = [],\n          halfCheckedKeys = []\n        } = checkedKeyEntity;\n        if (!props.checkStrictly) {\n          const conductKeys = conductCheck(checkedKeys, true, keyEntities);\n          ({\n            checkedKeys,\n            halfCheckedKeys\n          } = conductKeys);\n        }\n        newState.checkedKeys = checkedKeys;\n        newState.halfCheckedKeys = halfCheckedKeys;\n      }\n    }\n\n    // ================= loadedKeys ==================\n    if (needSync('loadedKeys')) {\n      newState.loadedKeys = props.loadedKeys;\n    }\n    return newState;\n  }\n  resetDragState() {\n    this.setState({\n      dragOverNodeKey: null,\n      dropPosition: null,\n      dropLevelOffset: null,\n      dropTargetKey: null,\n      dropContainerKey: null,\n      dropTargetPos: null,\n      dropAllowed: false\n    });\n  }\n  render() {\n    const {\n      flattenNodes,\n      keyEntities,\n      draggingNodeKey,\n      dropLevelOffset,\n      dropContainerKey,\n      dropTargetKey,\n      dropPosition,\n      dragOverNodeKey,\n      indent\n    } = this.state;\n    const {\n      prefixCls,\n      className,\n      style,\n      styles,\n      classNames: treeClassNames,\n      showLine,\n      focusable,\n      tabIndex = 0,\n      selectable,\n      showIcon,\n      icon,\n      switcherIcon,\n      draggable,\n      checkable,\n      checkStrictly,\n      disabled,\n      motion,\n      loadData,\n      filterTreeNode,\n      height,\n      itemHeight,\n      scrollWidth,\n      virtual,\n      titleRender,\n      dropIndicatorRender,\n      onContextMenu,\n      onScroll,\n      direction,\n      rootClassName,\n      rootStyle\n    } = this.props;\n    const domProps = pickAttrs(this.props, {\n      aria: true,\n      data: true\n    });\n\n    // It's better move to hooks but we just simply keep here\n    let draggableConfig;\n    if (draggable) {\n      if (typeof draggable === 'object') {\n        draggableConfig = draggable;\n      } else if (typeof draggable === 'function') {\n        draggableConfig = {\n          nodeDraggable: draggable\n        };\n      } else {\n        draggableConfig = {};\n      }\n    }\n    const contextValue = {\n      styles,\n      classNames: treeClassNames,\n      prefixCls,\n      selectable,\n      showIcon,\n      icon,\n      switcherIcon,\n      draggable: draggableConfig,\n      draggingNodeKey,\n      checkable,\n      checkStrictly,\n      disabled,\n      keyEntities,\n      dropLevelOffset,\n      dropContainerKey,\n      dropTargetKey,\n      dropPosition,\n      dragOverNodeKey,\n      indent,\n      direction,\n      dropIndicatorRender,\n      loadData,\n      filterTreeNode,\n      titleRender,\n      onNodeClick: this.onNodeClick,\n      onNodeDoubleClick: this.onNodeDoubleClick,\n      onNodeExpand: this.onNodeExpand,\n      onNodeSelect: this.onNodeSelect,\n      onNodeCheck: this.onNodeCheck,\n      onNodeLoad: this.onNodeLoad,\n      onNodeMouseEnter: this.onNodeMouseEnter,\n      onNodeMouseLeave: this.onNodeMouseLeave,\n      onNodeContextMenu: this.onNodeContextMenu,\n      onNodeDragStart: this.onNodeDragStart,\n      onNodeDragEnter: this.onNodeDragEnter,\n      onNodeDragOver: this.onNodeDragOver,\n      onNodeDragLeave: this.onNodeDragLeave,\n      onNodeDragEnd: this.onNodeDragEnd,\n      onNodeDrop: this.onNodeDrop\n    };\n    return /*#__PURE__*/React.createElement(TreeContext.Provider, {\n      value: contextValue\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: clsx(prefixCls, className, rootClassName, {\n        [\"\".concat(prefixCls, \"-show-line\")]: showLine\n      }),\n      style: rootStyle\n    }, /*#__PURE__*/React.createElement(NodeList, _extends({\n      ref: this.listRef,\n      prefixCls: prefixCls,\n      style: style,\n      data: flattenNodes,\n      disabled: disabled,\n      selectable: selectable,\n      checkable: !!checkable,\n      motion: motion,\n      dragging: draggingNodeKey !== null,\n      height: height,\n      itemHeight: itemHeight,\n      virtual: virtual,\n      focusable: focusable,\n      tabIndex: tabIndex,\n      activeItem: this.getActiveItem(),\n      onFocus: this.onFocus,\n      onBlur: this.onBlur,\n      onKeyDown: this.onKeyDown,\n      onActiveChange: this.onActiveChange,\n      onListChangeStart: this.onListChangeStart,\n      onListChangeEnd: this.onListChangeEnd,\n      onContextMenu: onContextMenu,\n      onScroll: onScroll,\n      scrollWidth: scrollWidth\n    }, this.getTreeNodeRequiredProps(), domProps))));\n  }\n}\n_defineProperty(Tree, \"defaultProps\", {\n  prefixCls: 'rc-tree',\n  showLine: false,\n  showIcon: true,\n  selectable: true,\n  multiple: false,\n  checkable: false,\n  disabled: false,\n  checkStrictly: false,\n  draggable: false,\n  defaultExpandParent: true,\n  autoExpandParent: false,\n  defaultExpandAll: false,\n  defaultExpandedKeys: [],\n  defaultCheckedKeys: [],\n  defaultSelectedKeys: [],\n  dropIndicatorRender: DropIndicator,\n  allowDrop: () => true,\n  expandAction: false\n});\n_defineProperty(Tree, \"TreeNode\", TreeNode);\nexport default Tree;","map":{"version":3,"names":["_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","clsx","pickAttrs","warning","React","TreeContext","DropIndicator","NodeList","MOTION_KEY","MotionEntity","TreeNode","arrAdd","arrDel","calcDropPosition","calcSelectedKeys","conductExpandParent","getDragChildrenKeys","parseCheckedKeys","posToArr","conductCheck","getEntity","convertDataToEntities","convertNodePropsToEventData","convertTreeToData","fillFieldNames","flattenTreeData","getTreeNodeProps","isLeafNode","warningWithoutKey","MAX_RETRY_TIMES","Tree","Component","constructor","_this","this","_defineProperty","keyEntities","indent","selectedKeys","checkedKeys","halfCheckedKeys","loadedKeys","loadingKeys","expandedKeys","draggingNodeKey","dragChildrenKeys","dropTargetKey","dropPosition","dropContainerKey","dropLevelOffset","dropTargetPos","dropAllowed","dragOverNodeKey","treeData","flattenNodes","activeKey","listChanging","prevProps","fieldNames","createRef","event","nodeProps","state","onDragStart","props","eventKey","dragNodeProps","dragStartMousePosition","x","clientX","y","clientY","newExpandedKeys","setState","listRef","current","getIndentWidth","setExpandedKeys","window","addEventListener","onWindowDragEnd","node","onDragEnter","onExpand","allowDrop","direction","pos","currentMouseOverDroppableNodeKey","resetDragState","includes","delayedDragEnterLogic","keys","forEach","clearTimeout","persist","setTimeout","entity","children","expanded","nativeEvent","onDragOver","currentTarget","contains","relatedTarget","onDragLeave","onNodeDragEnd","removeEventListener","onDragEnd","cleanDragState","_","_this$getActiveItem","outsideTree","undefined","onDrop","abstractDropNodeProps","_objectSpread","getTreeNodeRequiredProps","active","getActiveItem","data","dropToChild","posArr","dropResult","dragNode","dragNodesKeys","concat","dropToGap","Number","e","treeNode","isLeaf","shiftKey","metaKey","ctrlKey","filter","nodeItem","eventNode","onNodeExpand","onClick","expandAction","triggerExpandActionExpand","onDoubleClick","onSelect","multiple","selected","targetSelected","selectedNodes","map","selectedKey","Boolean","setUncontrolledState","checked","oriCheckedKeys","oriHalfCheckedKeys","checkStrictly","onCheck","checkedObj","eventObj","halfChecked","checkedNodes","checkedKey","keySet","Set","delete","Array","from","checkedNodesPositions","push","_entity$children","loadPromise","Promise","resolve","reject","_ref","loadData","onLoad","promise","then","currentLoadedKeys","newLoadedKeys","prevState","catch","loadingRetryTimes","onMouseEnter","onMouseLeave","onRightClick","preventDefault","onFocus","disabled","visibleSelectedKey","find","some","onActiveChange","_flattenNodes$","_len","args","_key","onBlur","_len2","_key2","certain","targetExpanded","onNodeLoad","newFlattenTreeData","currentExpandedKeys","expandedKeysToRestore","newActiveKey","itemScrollOffset","scrollTo","offset","_ref2","index","findIndex","_ref3","item","onKeyDown","checkable","selectable","offsetActiveKey","_flattenNodes$2","_flattenNodes","activeItem","_entity$children2","treeNodeRequiredProps","hasChildren","expandable","loaded","canCheck","disableCheckbox","canSelect","parent","onNodeCheck","onNodeSelect","atomic","forceState","destroyed","needSync","allPassed","newState","name","scroll","componentDidMount","onUpdated","componentDidUpdate","componentWillUnmount","getDerivedStateFromProps","entitiesMap","process","env","NODE_ENV","autoExpandParent","defaultExpandParent","defaultExpandAll","cloneKeyEntities","nextExpandedKeys","defaultExpandedKeys","defaultSelectedKeys","checkedKeyEntity","defaultCheckedKeys","conductKeys","render","prefixCls","className","style","styles","classNames","treeClassNames","showLine","focusable","tabIndex","showIcon","icon","switcherIcon","draggable","motion","filterTreeNode","height","itemHeight","scrollWidth","virtual","titleRender","dropIndicatorRender","onContextMenu","onScroll","rootClassName","rootStyle","domProps","aria","draggableConfig","nodeDraggable","contextValue","onNodeClick","onNodeDoubleClick","onNodeMouseEnter","onNodeMouseLeave","onNodeContextMenu","onNodeDragStart","onNodeDragEnter","onNodeDragOver","onNodeDragLeave","onNodeDrop","createElement","Provider","value","ref","dragging","onListChangeStart","onListChangeEnd"],"sources":["/Users/ferncliffadmin/clawd/projects/thesalessherpa/src/client/node_modules/@rc-component/tree/es/Tree.js"],"sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n// TODO: Fully accessibility support\n// Reference: https://www.w3.org/WAI/ARIA/apg/patterns/treeview\n\nimport { clsx } from 'clsx';\nimport pickAttrs from \"@rc-component/util/es/pickAttrs\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { TreeContext } from \"./contextTypes\";\nimport DropIndicator from \"./DropIndicator\";\nimport NodeList, { MOTION_KEY, MotionEntity } from \"./NodeList\";\nimport TreeNode from \"./TreeNode\";\nimport { arrAdd, arrDel, calcDropPosition, calcSelectedKeys, conductExpandParent, getDragChildrenKeys, parseCheckedKeys, posToArr } from \"./util\";\nimport { conductCheck } from \"./utils/conductUtil\";\nimport getEntity from \"./utils/keyUtil\";\nimport { convertDataToEntities, convertNodePropsToEventData, convertTreeToData, fillFieldNames, flattenTreeData, getTreeNodeProps, isLeafNode, warningWithoutKey } from \"./utils/treeUtil\";\nconst MAX_RETRY_TIMES = 10;\nclass Tree extends React.Component {\n  static defaultProps = {\n    prefixCls: 'rc-tree',\n    showLine: false,\n    showIcon: true,\n    selectable: true,\n    multiple: false,\n    checkable: false,\n    disabled: false,\n    checkStrictly: false,\n    draggable: false,\n    defaultExpandParent: true,\n    autoExpandParent: false,\n    defaultExpandAll: false,\n    defaultExpandedKeys: [],\n    defaultCheckedKeys: [],\n    defaultSelectedKeys: [],\n    dropIndicatorRender: DropIndicator,\n    allowDrop: () => true,\n    expandAction: false\n  };\n  static TreeNode = TreeNode;\n  destroyed = false;\n  delayedDragEnterLogic;\n  loadingRetryTimes = {};\n  state = {\n    keyEntities: {},\n    indent: null,\n    selectedKeys: [],\n    checkedKeys: [],\n    halfCheckedKeys: [],\n    loadedKeys: [],\n    loadingKeys: [],\n    expandedKeys: [],\n    draggingNodeKey: null,\n    dragChildrenKeys: [],\n    // dropTargetKey is the key of abstract-drop-node\n    // the abstract-drop-node is the real drop node when drag and drop\n    // not the DOM drag over node\n    dropTargetKey: null,\n    dropPosition: null,\n    // the drop position of abstract-drop-node, inside 0, top -1, bottom 1\n    dropContainerKey: null,\n    // the container key of abstract-drop-node if dropPosition is -1 or 1\n    dropLevelOffset: null,\n    // the drop level offset of abstract-drag-over-node\n    dropTargetPos: null,\n    // the pos of abstract-drop-node\n    dropAllowed: true,\n    // if drop to abstract-drop-node is allowed\n    // the abstract-drag-over-node\n    // if mouse is on the bottom of top dom node or no the top of the bottom dom node\n    // abstract-drag-over-node is the top node\n    dragOverNodeKey: null,\n    treeData: [],\n    flattenNodes: [],\n    activeKey: null,\n    listChanging: false,\n    prevProps: null,\n    fieldNames: fillFieldNames()\n  };\n  dragStartMousePosition = null;\n  dragNodeProps = null;\n  currentMouseOverDroppableNodeKey = null;\n  listRef = /*#__PURE__*/React.createRef();\n  componentDidMount() {\n    this.destroyed = false;\n    this.onUpdated();\n  }\n  componentDidUpdate() {\n    this.onUpdated();\n  }\n  onUpdated() {\n    const {\n      activeKey,\n      itemScrollOffset = 0\n    } = this.props;\n    if (activeKey !== undefined && activeKey !== this.state.activeKey) {\n      this.setState({\n        activeKey\n      });\n      if (activeKey !== null) {\n        this.scrollTo({\n          key: activeKey,\n          offset: itemScrollOffset\n        });\n      }\n    }\n  }\n  componentWillUnmount() {\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n    this.destroyed = true;\n  }\n  static getDerivedStateFromProps(props, prevState) {\n    const {\n      prevProps\n    } = prevState;\n    const newState = {\n      prevProps: props\n    };\n    function needSync(name) {\n      return !prevProps && props.hasOwnProperty(name) || prevProps && prevProps[name] !== props[name];\n    }\n\n    // ================== Tree Node ==================\n    let treeData;\n\n    // fieldNames\n    let {\n      fieldNames\n    } = prevState;\n    if (needSync('fieldNames')) {\n      fieldNames = fillFieldNames(props.fieldNames);\n      newState.fieldNames = fieldNames;\n    }\n\n    // Check if `treeData` or `children` changed and save into the state.\n    if (needSync('treeData')) {\n      ({\n        treeData\n      } = props);\n    } else if (needSync('children')) {\n      warning(false, '`children` of Tree is deprecated. Please use `treeData` instead.');\n      treeData = convertTreeToData(props.children);\n    }\n\n    // Save flatten nodes info and convert `treeData` into keyEntities\n    if (treeData) {\n      newState.treeData = treeData;\n      const entitiesMap = convertDataToEntities(treeData, {\n        fieldNames\n      });\n      newState.keyEntities = {\n        [MOTION_KEY]: MotionEntity,\n        ...entitiesMap.keyEntities\n      };\n\n      // Warning if treeNode not provide key\n      if (process.env.NODE_ENV !== 'production') {\n        warningWithoutKey(treeData, fieldNames);\n      }\n    }\n    const keyEntities = newState.keyEntities || prevState.keyEntities;\n\n    // ================ expandedKeys =================\n    if (needSync('expandedKeys') || prevProps && needSync('autoExpandParent')) {\n      newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;\n    } else if (!prevProps && props.defaultExpandAll) {\n      const cloneKeyEntities = {\n        ...keyEntities\n      };\n      delete cloneKeyEntities[MOTION_KEY];\n\n      // Only take the key who has the children to enhance the performance\n      const nextExpandedKeys = [];\n      Object.keys(cloneKeyEntities).forEach(key => {\n        const entity = cloneKeyEntities[key];\n        if (entity.children && entity.children.length) {\n          nextExpandedKeys.push(entity.key);\n        }\n      });\n      newState.expandedKeys = nextExpandedKeys;\n    } else if (!prevProps && props.defaultExpandedKeys) {\n      newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;\n    }\n    if (!newState.expandedKeys) {\n      delete newState.expandedKeys;\n    }\n\n    // ================ flattenNodes =================\n    if (treeData || newState.expandedKeys) {\n      const flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);\n      newState.flattenNodes = flattenNodes;\n    }\n\n    // ================ selectedKeys =================\n    if (props.selectable) {\n      if (needSync('selectedKeys')) {\n        newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);\n      } else if (!prevProps && props.defaultSelectedKeys) {\n        newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);\n      }\n    }\n\n    // ================= checkedKeys =================\n    if (props.checkable) {\n      let checkedKeyEntity;\n      if (needSync('checkedKeys')) {\n        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};\n      } else if (!prevProps && props.defaultCheckedKeys) {\n        checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};\n      } else if (treeData) {\n        // If `treeData` changed, we also need check it\n        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {\n          checkedKeys: prevState.checkedKeys,\n          halfCheckedKeys: prevState.halfCheckedKeys\n        };\n      }\n      if (checkedKeyEntity) {\n        let {\n          checkedKeys = [],\n          halfCheckedKeys = []\n        } = checkedKeyEntity;\n        if (!props.checkStrictly) {\n          const conductKeys = conductCheck(checkedKeys, true, keyEntities);\n          ({\n            checkedKeys,\n            halfCheckedKeys\n          } = conductKeys);\n        }\n        newState.checkedKeys = checkedKeys;\n        newState.halfCheckedKeys = halfCheckedKeys;\n      }\n    }\n\n    // ================= loadedKeys ==================\n    if (needSync('loadedKeys')) {\n      newState.loadedKeys = props.loadedKeys;\n    }\n    return newState;\n  }\n  onNodeDragStart = (event, nodeProps) => {\n    const {\n      expandedKeys,\n      keyEntities\n    } = this.state;\n    const {\n      onDragStart\n    } = this.props;\n    const {\n      eventKey\n    } = nodeProps;\n    this.dragNodeProps = nodeProps;\n    this.dragStartMousePosition = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    const newExpandedKeys = arrDel(expandedKeys, eventKey);\n    this.setState({\n      draggingNodeKey: eventKey,\n      dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),\n      indent: this.listRef.current.getIndentWidth()\n    });\n    this.setExpandedKeys(newExpandedKeys);\n    window.addEventListener('dragend', this.onWindowDragEnd);\n    onDragStart?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n  };\n\n  /**\n   * [Legacy] Select handler is smaller than node,\n   * so that this will trigger when drag enter node or select handler.\n   * This is a little tricky if customize css without padding.\n   * Better for use mouse move event to refresh drag state.\n   * But let's just keep it to avoid event trigger logic change.\n   */\n  onNodeDragEnter = (event, nodeProps) => {\n    const {\n      expandedKeys,\n      keyEntities,\n      dragChildrenKeys,\n      flattenNodes,\n      indent\n    } = this.state;\n    const {\n      onDragEnter,\n      onExpand,\n      allowDrop,\n      direction\n    } = this.props;\n    const {\n      pos,\n      eventKey\n    } = nodeProps;\n\n    // record the key of node which is latest entered, used in dragleave event.\n    if (this.currentMouseOverDroppableNodeKey !== eventKey) {\n      this.currentMouseOverDroppableNodeKey = eventKey;\n    }\n    if (!this.dragNodeProps) {\n      this.resetDragState();\n      return;\n    }\n    const {\n      dropPosition,\n      dropLevelOffset,\n      dropTargetKey,\n      dropContainerKey,\n      dropTargetPos,\n      dropAllowed,\n      dragOverNodeKey\n    } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);\n    if (\n    // don't allow drop inside its children\n    dragChildrenKeys.includes(dropTargetKey) ||\n    // don't allow drop when drop is not allowed caculated by calcDropPosition\n    !dropAllowed) {\n      this.resetDragState();\n      return;\n    }\n\n    // Side effect for delay drag\n    if (!this.delayedDragEnterLogic) {\n      this.delayedDragEnterLogic = {};\n    }\n    Object.keys(this.delayedDragEnterLogic).forEach(key => {\n      clearTimeout(this.delayedDragEnterLogic[key]);\n    });\n    if (this.dragNodeProps.eventKey !== nodeProps.eventKey) {\n      // hoist expand logic here\n      // since if logic is on the bottom\n      // it will be blocked by abstract dragover node check\n      //   => if you dragenter from top, you mouse will still be consider as in the top node\n      event.persist();\n      this.delayedDragEnterLogic[pos] = window.setTimeout(() => {\n        if (this.state.draggingNodeKey === null) {\n          return;\n        }\n        let newExpandedKeys = [...expandedKeys];\n        const entity = getEntity(keyEntities, nodeProps.eventKey);\n        if (entity && (entity.children || []).length) {\n          newExpandedKeys = arrAdd(expandedKeys, nodeProps.eventKey);\n        }\n        if (!this.props.hasOwnProperty('expandedKeys')) {\n          this.setExpandedKeys(newExpandedKeys);\n        }\n        onExpand?.(newExpandedKeys, {\n          node: convertNodePropsToEventData(nodeProps),\n          expanded: true,\n          nativeEvent: event.nativeEvent\n        });\n      }, 800);\n    }\n\n    // Skip if drag node is self\n    if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {\n      this.resetDragState();\n      return;\n    }\n\n    // Update drag over node and drag state\n    this.setState({\n      dragOverNodeKey,\n      dropPosition,\n      dropLevelOffset,\n      dropTargetKey,\n      dropContainerKey,\n      dropTargetPos,\n      dropAllowed\n    });\n    onDragEnter?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps),\n      expandedKeys\n    });\n  };\n  onNodeDragOver = (event, nodeProps) => {\n    const {\n      dragChildrenKeys,\n      flattenNodes,\n      keyEntities,\n      expandedKeys,\n      indent\n    } = this.state;\n    const {\n      onDragOver,\n      allowDrop,\n      direction\n    } = this.props;\n    if (!this.dragNodeProps) {\n      return;\n    }\n    const {\n      dropPosition,\n      dropLevelOffset,\n      dropTargetKey,\n      dropContainerKey,\n      dropTargetPos,\n      dropAllowed,\n      dragOverNodeKey\n    } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);\n    if (dragChildrenKeys.includes(dropTargetKey) || !dropAllowed) {\n      // don't allow drop inside its children\n      // don't allow drop when drop is not allowed calculated by calcDropPosition\n      return;\n    }\n\n    // Update drag position\n\n    if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {\n      if (!(this.state.dropPosition === null && this.state.dropLevelOffset === null && this.state.dropTargetKey === null && this.state.dropContainerKey === null && this.state.dropTargetPos === null && this.state.dropAllowed === false && this.state.dragOverNodeKey === null)) {\n        this.resetDragState();\n      }\n    } else if (!(dropPosition === this.state.dropPosition && dropLevelOffset === this.state.dropLevelOffset && dropTargetKey === this.state.dropTargetKey && dropContainerKey === this.state.dropContainerKey && dropTargetPos === this.state.dropTargetPos && dropAllowed === this.state.dropAllowed && dragOverNodeKey === this.state.dragOverNodeKey)) {\n      this.setState({\n        dropPosition,\n        dropLevelOffset,\n        dropTargetKey,\n        dropContainerKey,\n        dropTargetPos,\n        dropAllowed,\n        dragOverNodeKey\n      });\n    }\n    onDragOver?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n  };\n  onNodeDragLeave = (event, nodeProps) => {\n    // if it is outside the droppable area\n    // currentMouseOverDroppableNodeKey will be updated in dragenter event when into another droppable receiver.\n    if (this.currentMouseOverDroppableNodeKey === nodeProps.eventKey && !event.currentTarget.contains(event.relatedTarget)) {\n      this.resetDragState();\n      this.currentMouseOverDroppableNodeKey = null;\n    }\n    const {\n      onDragLeave\n    } = this.props;\n    onDragLeave?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n  };\n\n  // since stopPropagation() is called in treeNode\n  // if onWindowDrag is called, whice means state is keeped, drag state should be cleared\n  onWindowDragEnd = event => {\n    this.onNodeDragEnd(event, null, true);\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n  };\n\n  // if onNodeDragEnd is called, onWindowDragEnd won't be called since stopPropagation() is called\n  onNodeDragEnd = (event, nodeProps) => {\n    const {\n      onDragEnd\n    } = this.props;\n    this.setState({\n      dragOverNodeKey: null\n    });\n    this.cleanDragState();\n    onDragEnd?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n    this.dragNodeProps = null;\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n  };\n  onNodeDrop = (event, _, outsideTree = false) => {\n    const {\n      dragChildrenKeys,\n      dropPosition,\n      dropTargetKey,\n      dropTargetPos,\n      dropAllowed\n    } = this.state;\n    if (!dropAllowed) {\n      return;\n    }\n    const {\n      onDrop\n    } = this.props;\n    this.setState({\n      dragOverNodeKey: null\n    });\n    this.cleanDragState();\n    if (dropTargetKey === null) return;\n    const abstractDropNodeProps = {\n      ...getTreeNodeProps(dropTargetKey, this.getTreeNodeRequiredProps()),\n      active: this.getActiveItem()?.key === dropTargetKey,\n      data: getEntity(this.state.keyEntities, dropTargetKey).node\n    };\n    const dropToChild = dragChildrenKeys.includes(dropTargetKey);\n    warning(!dropToChild, \"Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.\");\n    const posArr = posToArr(dropTargetPos);\n    const dropResult = {\n      event,\n      node: convertNodePropsToEventData(abstractDropNodeProps),\n      dragNode: this.dragNodeProps ? convertNodePropsToEventData(this.dragNodeProps) : null,\n      dragNodesKeys: [this.dragNodeProps.eventKey].concat(dragChildrenKeys),\n      dropToGap: dropPosition !== 0,\n      dropPosition: dropPosition + Number(posArr[posArr.length - 1])\n    };\n    if (!outsideTree) {\n      onDrop?.(dropResult);\n    }\n    this.dragNodeProps = null;\n  };\n  resetDragState() {\n    this.setState({\n      dragOverNodeKey: null,\n      dropPosition: null,\n      dropLevelOffset: null,\n      dropTargetKey: null,\n      dropContainerKey: null,\n      dropTargetPos: null,\n      dropAllowed: false\n    });\n  }\n  cleanDragState = () => {\n    const {\n      draggingNodeKey\n    } = this.state;\n    if (draggingNodeKey !== null) {\n      this.setState({\n        draggingNodeKey: null,\n        dropPosition: null,\n        dropContainerKey: null,\n        dropTargetKey: null,\n        dropLevelOffset: null,\n        dropAllowed: true,\n        dragOverNodeKey: null\n      });\n    }\n    this.dragStartMousePosition = null;\n    this.currentMouseOverDroppableNodeKey = null;\n  };\n  triggerExpandActionExpand = (e, treeNode) => {\n    const {\n      expandedKeys,\n      flattenNodes\n    } = this.state;\n    const {\n      expanded,\n      key,\n      isLeaf\n    } = treeNode;\n    if (isLeaf || e.shiftKey || e.metaKey || e.ctrlKey) {\n      return;\n    }\n    const node = flattenNodes.filter(nodeItem => nodeItem.key === key)[0];\n    const eventNode = convertNodePropsToEventData({\n      ...getTreeNodeProps(key, this.getTreeNodeRequiredProps()),\n      data: node.data\n    });\n    this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));\n    this.onNodeExpand(e, eventNode);\n  };\n  onNodeClick = (e, treeNode) => {\n    const {\n      onClick,\n      expandAction\n    } = this.props;\n    if (expandAction === 'click') {\n      this.triggerExpandActionExpand(e, treeNode);\n    }\n    onClick?.(e, treeNode);\n  };\n  onNodeDoubleClick = (e, treeNode) => {\n    const {\n      onDoubleClick,\n      expandAction\n    } = this.props;\n    if (expandAction === 'doubleClick') {\n      this.triggerExpandActionExpand(e, treeNode);\n    }\n    onDoubleClick?.(e, treeNode);\n  };\n  onNodeSelect = (e, treeNode) => {\n    let {\n      selectedKeys\n    } = this.state;\n    const {\n      keyEntities,\n      fieldNames\n    } = this.state;\n    const {\n      onSelect,\n      multiple\n    } = this.props;\n    const {\n      selected\n    } = treeNode;\n    const key = treeNode[fieldNames.key];\n    const targetSelected = !selected;\n\n    // Update selected keys\n    if (!targetSelected) {\n      selectedKeys = arrDel(selectedKeys, key);\n    } else if (!multiple) {\n      selectedKeys = [key];\n    } else {\n      selectedKeys = arrAdd(selectedKeys, key);\n    }\n\n    // [Legacy] Not found related usage in doc or upper libs\n    const selectedNodes = selectedKeys.map(selectedKey => {\n      const entity = getEntity(keyEntities, selectedKey);\n      return entity ? entity.node : null;\n    }).filter(Boolean);\n    this.setUncontrolledState({\n      selectedKeys\n    });\n    onSelect?.(selectedKeys, {\n      event: 'select',\n      selected: targetSelected,\n      node: treeNode,\n      selectedNodes,\n      nativeEvent: e.nativeEvent\n    });\n  };\n  onNodeCheck = (e, treeNode, checked) => {\n    const {\n      keyEntities,\n      checkedKeys: oriCheckedKeys,\n      halfCheckedKeys: oriHalfCheckedKeys\n    } = this.state;\n    const {\n      checkStrictly,\n      onCheck\n    } = this.props;\n    const {\n      key\n    } = treeNode;\n\n    // Prepare trigger arguments\n    let checkedObj;\n    const eventObj = {\n      event: 'check',\n      node: treeNode,\n      checked,\n      nativeEvent: e.nativeEvent\n    };\n    if (checkStrictly) {\n      const checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);\n      const halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);\n      checkedObj = {\n        checked: checkedKeys,\n        halfChecked: halfCheckedKeys\n      };\n      eventObj.checkedNodes = checkedKeys.map(checkedKey => getEntity(keyEntities, checkedKey)).filter(Boolean).map(entity => entity.node);\n      this.setUncontrolledState({\n        checkedKeys\n      });\n    } else {\n      // Always fill first\n      let {\n        checkedKeys,\n        halfCheckedKeys\n      } = conductCheck([...oriCheckedKeys, key], true, keyEntities);\n\n      // If remove, we do it again to correction\n      if (!checked) {\n        const keySet = new Set(checkedKeys);\n        keySet.delete(key);\n        ({\n          checkedKeys,\n          halfCheckedKeys\n        } = conductCheck(Array.from(keySet), {\n          checked: false,\n          halfCheckedKeys\n        }, keyEntities));\n      }\n      checkedObj = checkedKeys;\n\n      // [Legacy] This is used for `rc-tree-select`\n      eventObj.checkedNodes = [];\n      eventObj.checkedNodesPositions = [];\n      eventObj.halfCheckedKeys = halfCheckedKeys;\n      checkedKeys.forEach(checkedKey => {\n        const entity = getEntity(keyEntities, checkedKey);\n        if (!entity) return;\n        const {\n          node,\n          pos\n        } = entity;\n        eventObj.checkedNodes.push(node);\n        eventObj.checkedNodesPositions.push({\n          node,\n          pos\n        });\n      });\n      this.setUncontrolledState({\n        checkedKeys\n      }, false, {\n        halfCheckedKeys\n      });\n    }\n    onCheck?.(checkedObj, eventObj);\n  };\n  onNodeLoad = treeNode => {\n    const {\n      key\n    } = treeNode;\n    const {\n      keyEntities\n    } = this.state;\n\n    // Skip if has children already\n    const entity = getEntity(keyEntities, key);\n    if (entity?.children?.length) {\n      return;\n    }\n    const loadPromise = new Promise((resolve, reject) => {\n      // We need to get the latest state of loading/loaded keys\n      this.setState(({\n        loadedKeys = [],\n        loadingKeys = []\n      }) => {\n        const {\n          loadData,\n          onLoad\n        } = this.props;\n        if (!loadData || loadedKeys.includes(key) || loadingKeys.includes(key)) {\n          return null;\n        }\n\n        // Process load data\n        const promise = loadData(treeNode);\n        promise.then(() => {\n          const {\n            loadedKeys: currentLoadedKeys\n          } = this.state;\n          const newLoadedKeys = arrAdd(currentLoadedKeys, key);\n\n          // onLoad should trigger before internal setState to avoid `loadData` trigger twice.\n          // https://github.com/ant-design/ant-design/issues/12464\n          onLoad?.(newLoadedKeys, {\n            event: 'load',\n            node: treeNode\n          });\n          this.setUncontrolledState({\n            loadedKeys: newLoadedKeys\n          });\n          this.setState(prevState => ({\n            loadingKeys: arrDel(prevState.loadingKeys, key)\n          }));\n          resolve();\n        }).catch(e => {\n          this.setState(prevState => ({\n            loadingKeys: arrDel(prevState.loadingKeys, key)\n          }));\n\n          // If exceed max retry times, we give up retry\n          this.loadingRetryTimes[key] = (this.loadingRetryTimes[key] || 0) + 1;\n          if (this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {\n            const {\n              loadedKeys: currentLoadedKeys\n            } = this.state;\n            warning(false, 'Retry for `loadData` many times but still failed. No more retry.');\n            this.setUncontrolledState({\n              loadedKeys: arrAdd(currentLoadedKeys, key)\n            });\n            resolve();\n          }\n          reject(e);\n        });\n        return {\n          loadingKeys: arrAdd(loadingKeys, key)\n        };\n      });\n    });\n\n    // Not care warning if we ignore this\n    loadPromise.catch(() => {});\n    return loadPromise;\n  };\n  onNodeMouseEnter = (event, node) => {\n    const {\n      onMouseEnter\n    } = this.props;\n    onMouseEnter?.({\n      event,\n      node\n    });\n  };\n  onNodeMouseLeave = (event, node) => {\n    const {\n      onMouseLeave\n    } = this.props;\n    onMouseLeave?.({\n      event,\n      node\n    });\n  };\n  onNodeContextMenu = (event, node) => {\n    const {\n      onRightClick\n    } = this.props;\n    if (onRightClick) {\n      event.preventDefault();\n      onRightClick({\n        event,\n        node\n      });\n    }\n  };\n  onFocus = (...args) => {\n    const {\n      onFocus,\n      disabled\n    } = this.props;\n    const {\n      activeKey,\n      selectedKeys,\n      flattenNodes\n    } = this.state;\n    if (!disabled && activeKey === null) {\n      const visibleSelectedKey = selectedKeys.find(key => {\n        return flattenNodes.some(nodeItem => nodeItem.key === key);\n      });\n      if (visibleSelectedKey !== undefined) {\n        this.onActiveChange(visibleSelectedKey);\n      } else {\n        this.onActiveChange(flattenNodes?.[0]?.key || null);\n      }\n    }\n    onFocus?.(...args);\n  };\n  onBlur = (...args) => {\n    const {\n      onBlur\n    } = this.props;\n    this.onActiveChange(null);\n    onBlur?.(...args);\n  };\n  getTreeNodeRequiredProps = () => {\n    const {\n      expandedKeys,\n      selectedKeys,\n      loadedKeys,\n      loadingKeys,\n      checkedKeys,\n      halfCheckedKeys,\n      dragOverNodeKey,\n      dropPosition,\n      keyEntities\n    } = this.state;\n    return {\n      expandedKeys: expandedKeys || [],\n      selectedKeys: selectedKeys || [],\n      loadedKeys: loadedKeys || [],\n      loadingKeys: loadingKeys || [],\n      checkedKeys: checkedKeys || [],\n      halfCheckedKeys: halfCheckedKeys || [],\n      dragOverNodeKey,\n      dropPosition,\n      keyEntities: keyEntities\n    };\n  };\n\n  // =========================== Expanded ===========================\n  /** Set uncontrolled `expandedKeys`. This will also auto update `flattenNodes`. */\n  setExpandedKeys = expandedKeys => {\n    const {\n      treeData,\n      fieldNames\n    } = this.state;\n    const flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);\n    this.setUncontrolledState({\n      expandedKeys,\n      flattenNodes\n    }, true);\n  };\n  onNodeExpand = (e, treeNode) => {\n    let {\n      expandedKeys\n    } = this.state;\n    const {\n      listChanging,\n      fieldNames\n    } = this.state;\n    const {\n      onExpand,\n      loadData\n    } = this.props;\n    const {\n      expanded\n    } = treeNode;\n    const key = treeNode[fieldNames.key];\n\n    // Do nothing when motion is in progress\n    if (listChanging) {\n      return;\n    }\n\n    // Update selected keys\n    const certain = expandedKeys.includes(key);\n    const targetExpanded = !expanded;\n    warning(expanded && certain || !expanded && !certain, 'Expand state not sync with index check');\n    expandedKeys = targetExpanded ? arrAdd(expandedKeys, key) : arrDel(expandedKeys, key);\n    this.setExpandedKeys(expandedKeys);\n    onExpand?.(expandedKeys, {\n      node: treeNode,\n      expanded: targetExpanded,\n      nativeEvent: e.nativeEvent\n    });\n\n    // Async Load data\n    if (targetExpanded && loadData) {\n      const loadPromise = this.onNodeLoad(treeNode);\n      if (loadPromise) {\n        loadPromise.then(() => {\n          // [Legacy] Refresh logic\n          const newFlattenTreeData = flattenTreeData(this.state.treeData, expandedKeys, fieldNames);\n          this.setUncontrolledState({\n            flattenNodes: newFlattenTreeData\n          });\n        }).catch(() => {\n          const {\n            expandedKeys: currentExpandedKeys\n          } = this.state;\n          const expandedKeysToRestore = arrDel(currentExpandedKeys, key);\n          this.setExpandedKeys(expandedKeysToRestore);\n        });\n      }\n    }\n  };\n  onListChangeStart = () => {\n    this.setUncontrolledState({\n      listChanging: true\n    });\n  };\n  onListChangeEnd = () => {\n    setTimeout(() => {\n      this.setUncontrolledState({\n        listChanging: false\n      });\n    });\n  };\n\n  // =========================== Keyboard ===========================\n  onActiveChange = newActiveKey => {\n    const {\n      activeKey\n    } = this.state;\n    const {\n      onActiveChange,\n      itemScrollOffset = 0\n    } = this.props;\n    if (activeKey === newActiveKey) {\n      return;\n    }\n    this.setState({\n      activeKey: newActiveKey\n    });\n    if (newActiveKey !== null) {\n      this.scrollTo({\n        key: newActiveKey,\n        offset: itemScrollOffset\n      });\n    }\n    onActiveChange?.(newActiveKey);\n  };\n  getActiveItem = () => {\n    const {\n      activeKey,\n      flattenNodes\n    } = this.state;\n    if (activeKey === null) {\n      return null;\n    }\n    return flattenNodes.find(({\n      key\n    }) => key === activeKey) || null;\n  };\n  offsetActiveKey = offset => {\n    const {\n      flattenNodes,\n      activeKey\n    } = this.state;\n    let index = flattenNodes.findIndex(({\n      key\n    }) => key === activeKey);\n\n    // Align with index\n    if (index === -1 && offset < 0) {\n      index = flattenNodes.length;\n    }\n    index = (index + offset + flattenNodes.length) % flattenNodes.length;\n    const item = flattenNodes[index];\n    if (item) {\n      const {\n        key\n      } = item;\n      this.onActiveChange(key);\n    } else {\n      this.onActiveChange(null);\n    }\n  };\n  onKeyDown = event => {\n    const {\n      activeKey,\n      expandedKeys,\n      checkedKeys,\n      flattenNodes,\n      keyEntities\n    } = this.state;\n    const {\n      onKeyDown,\n      checkable,\n      selectable,\n      disabled,\n      loadData\n    } = this.props;\n    if (disabled) {\n      return;\n    }\n\n    // >>>>>>>>>> Direction\n    switch (event.key) {\n      case 'ArrowUp':\n        {\n          this.offsetActiveKey(-1);\n          event.preventDefault();\n          break;\n        }\n      case 'ArrowDown':\n        {\n          this.offsetActiveKey(1);\n          event.preventDefault();\n          break;\n        }\n      case 'Home':\n        {\n          this.onActiveChange(flattenNodes?.[0]?.key);\n          event.preventDefault();\n          break;\n        }\n      case 'End':\n        {\n          this.onActiveChange(flattenNodes?.[flattenNodes.length - 1]?.key);\n          event.preventDefault();\n          break;\n        }\n    }\n\n    // >>>>>>>>>> Expand & Selection\n    const activeItem = this.getActiveItem();\n    if (activeItem && activeItem.data) {\n      const treeNodeRequiredProps = this.getTreeNodeRequiredProps();\n      const eventNode = convertNodePropsToEventData({\n        ...getTreeNodeProps(activeKey, treeNodeRequiredProps),\n        data: activeItem.data,\n        active: true\n      });\n      const entity = getEntity(keyEntities, activeKey);\n      const hasChildren = !!entity?.children?.length;\n      const expandable = !isLeafNode(activeItem.data.isLeaf, loadData, hasChildren, eventNode.loaded);\n      const canCheck = checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox;\n      const canSelect = !checkable && selectable && !eventNode.disabled && eventNode.selectable !== false;\n      switch (event.key) {\n        // >>> Expand\n        case 'ArrowLeft':\n          {\n            // Collapse if possible\n            if (expandable && expandedKeys.includes(activeKey)) {\n              this.onNodeExpand({}, eventNode);\n            } else if (activeItem.parent) {\n              this.onActiveChange(activeItem.parent.key);\n            }\n            event.preventDefault();\n            break;\n          }\n        case 'ArrowRight':\n          {\n            // Expand if possible\n            if (expandable && !expandedKeys.includes(activeKey)) {\n              this.onNodeExpand({}, eventNode);\n            } else if (activeItem.children && activeItem.children.length) {\n              this.onActiveChange(activeItem.children[0].key);\n            }\n            event.preventDefault();\n            break;\n          }\n        case 'Enter':\n          {\n            if (expandable) {\n              event.preventDefault();\n              this.onNodeExpand({}, eventNode);\n            } else if (canCheck) {\n              if (!checkedKeys.includes(activeKey)) {\n                event.preventDefault();\n                this.onNodeCheck({}, eventNode, true);\n              }\n            } else if (canSelect && !eventNode.selected) {\n              event.preventDefault();\n              this.onNodeSelect({}, eventNode);\n            }\n            break;\n          }\n        case ' ':\n          {\n            if (canCheck) {\n              event.preventDefault();\n              this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));\n            } else if (canSelect) {\n              event.preventDefault();\n              this.onNodeSelect({}, eventNode);\n            }\n            break;\n          }\n      }\n    }\n    onKeyDown?.(event);\n  };\n\n  /**\n   * Only update the value which is not in props\n   */\n  setUncontrolledState = (state, atomic = false, forceState = null) => {\n    if (!this.destroyed) {\n      let needSync = false;\n      let allPassed = true;\n      const newState = {};\n      Object.keys(state).forEach(name => {\n        if (this.props.hasOwnProperty(name)) {\n          allPassed = false;\n          return;\n        }\n        needSync = true;\n        newState[name] = state[name];\n      });\n      if (needSync && (!atomic || allPassed)) {\n        this.setState({\n          ...newState,\n          ...forceState\n        });\n      }\n    }\n  };\n  scrollTo = scroll => {\n    this.listRef.current.scrollTo(scroll);\n  };\n  render() {\n    const {\n      flattenNodes,\n      keyEntities,\n      draggingNodeKey,\n      dropLevelOffset,\n      dropContainerKey,\n      dropTargetKey,\n      dropPosition,\n      dragOverNodeKey,\n      indent\n    } = this.state;\n    const {\n      prefixCls,\n      className,\n      style,\n      styles,\n      classNames: treeClassNames,\n      showLine,\n      focusable,\n      tabIndex = 0,\n      selectable,\n      showIcon,\n      icon,\n      switcherIcon,\n      draggable,\n      checkable,\n      checkStrictly,\n      disabled,\n      motion,\n      loadData,\n      filterTreeNode,\n      height,\n      itemHeight,\n      scrollWidth,\n      virtual,\n      titleRender,\n      dropIndicatorRender,\n      onContextMenu,\n      onScroll,\n      direction,\n      rootClassName,\n      rootStyle\n    } = this.props;\n    const domProps = pickAttrs(this.props, {\n      aria: true,\n      data: true\n    });\n\n    // It's better move to hooks but we just simply keep here\n    let draggableConfig;\n    if (draggable) {\n      if (typeof draggable === 'object') {\n        draggableConfig = draggable;\n      } else if (typeof draggable === 'function') {\n        draggableConfig = {\n          nodeDraggable: draggable\n        };\n      } else {\n        draggableConfig = {};\n      }\n    }\n    const contextValue = {\n      styles,\n      classNames: treeClassNames,\n      prefixCls,\n      selectable,\n      showIcon,\n      icon,\n      switcherIcon,\n      draggable: draggableConfig,\n      draggingNodeKey,\n      checkable,\n      checkStrictly,\n      disabled,\n      keyEntities,\n      dropLevelOffset,\n      dropContainerKey,\n      dropTargetKey,\n      dropPosition,\n      dragOverNodeKey,\n      indent,\n      direction,\n      dropIndicatorRender,\n      loadData,\n      filterTreeNode,\n      titleRender,\n      onNodeClick: this.onNodeClick,\n      onNodeDoubleClick: this.onNodeDoubleClick,\n      onNodeExpand: this.onNodeExpand,\n      onNodeSelect: this.onNodeSelect,\n      onNodeCheck: this.onNodeCheck,\n      onNodeLoad: this.onNodeLoad,\n      onNodeMouseEnter: this.onNodeMouseEnter,\n      onNodeMouseLeave: this.onNodeMouseLeave,\n      onNodeContextMenu: this.onNodeContextMenu,\n      onNodeDragStart: this.onNodeDragStart,\n      onNodeDragEnter: this.onNodeDragEnter,\n      onNodeDragOver: this.onNodeDragOver,\n      onNodeDragLeave: this.onNodeDragLeave,\n      onNodeDragEnd: this.onNodeDragEnd,\n      onNodeDrop: this.onNodeDrop\n    };\n    return /*#__PURE__*/React.createElement(TreeContext.Provider, {\n      value: contextValue\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: clsx(prefixCls, className, rootClassName, {\n        [`${prefixCls}-show-line`]: showLine\n      }),\n      style: rootStyle\n    }, /*#__PURE__*/React.createElement(NodeList, _extends({\n      ref: this.listRef,\n      prefixCls: prefixCls,\n      style: style,\n      data: flattenNodes,\n      disabled: disabled,\n      selectable: selectable,\n      checkable: !!checkable,\n      motion: motion,\n      dragging: draggingNodeKey !== null,\n      height: height,\n      itemHeight: itemHeight,\n      virtual: virtual,\n      focusable: focusable,\n      tabIndex: tabIndex,\n      activeItem: this.getActiveItem(),\n      onFocus: this.onFocus,\n      onBlur: this.onBlur,\n      onKeyDown: this.onKeyDown,\n      onActiveChange: this.onActiveChange,\n      onListChangeStart: this.onListChangeStart,\n      onListChangeEnd: this.onListChangeEnd,\n      onContextMenu: onContextMenu,\n      onScroll: onScroll,\n      scrollWidth: scrollWidth\n    }, this.getTreeNodeRequiredProps(), domProps))));\n  }\n}\nexport default Tree;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}