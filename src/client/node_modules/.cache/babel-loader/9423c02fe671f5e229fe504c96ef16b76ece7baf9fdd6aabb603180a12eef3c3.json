{"ast":null,"code":"import _objectSpread from \"/Users/ferncliffadmin/clawd/projects/thesalessherpa/src/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { isDOM } from \"@rc-component/util/es/Dom/findDOMNode\";\nimport isVisible from \"@rc-component/util/es/Dom/isVisible\";\nimport useEvent from \"@rc-component/util/es/hooks/useEvent\";\nimport useLayoutEffect from \"@rc-component/util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\nimport { collectScroller, getVisibleArea, getWin, toNum } from \"../util\";\nfunction getUnitOffset(size) {\n  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const offsetStr = \"\".concat(offset);\n  const cells = offsetStr.match(/^(.*)\\%$/);\n  if (cells) {\n    return size * (parseFloat(cells[1]) / 100);\n  }\n  return parseFloat(offsetStr);\n}\nfunction getNumberOffset(rect, offset) {\n  const [offsetX, offsetY] = offset || [];\n  return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];\n}\nfunction splitPoints() {\n  let points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return [points[0], points[1]];\n}\nfunction getAlignPoint(rect, points) {\n  const topBottom = points[0];\n  const leftRight = points[1];\n  let x;\n  let y;\n\n  // Top & Bottom\n  if (topBottom === 't') {\n    y = rect.y;\n  } else if (topBottom === 'b') {\n    y = rect.y + rect.height;\n  } else {\n    y = rect.y + rect.height / 2;\n  }\n\n  // Left & Right\n  if (leftRight === 'l') {\n    x = rect.x;\n  } else if (leftRight === 'r') {\n    x = rect.x + rect.width;\n  } else {\n    x = rect.x + rect.width / 2;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction reversePoints(points, index) {\n  const reverseMap = {\n    t: 'b',\n    b: 't',\n    l: 'r',\n    r: 'l'\n  };\n  const clone = [...points];\n  clone[index] = reverseMap[points[index]] || 'c';\n  return clone;\n}\nfunction flatPoints(points) {\n  return points.join('');\n}\nexport default function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign, mobile) {\n  const [offsetInfo, setOffsetInfo] = React.useState({\n    ready: false,\n    offsetX: 0,\n    offsetY: 0,\n    offsetR: 0,\n    offsetB: 0,\n    arrowX: 0,\n    arrowY: 0,\n    scaleX: 1,\n    scaleY: 1,\n    align: builtinPlacements[placement] || {}\n  });\n  const alignCountRef = React.useRef(0);\n  const scrollerList = React.useMemo(() => {\n    if (!popupEle || mobile) {\n      return [];\n    }\n    return collectScroller(popupEle);\n  }, [popupEle]);\n\n  // ========================= Flip ==========================\n  // We will memo flip info.\n  // If size change to make flip, it will memo the flip info and use it in next align.\n  const prevFlipRef = React.useRef({});\n  const resetFlipCache = () => {\n    prevFlipRef.current = {};\n  };\n  if (!open) {\n    resetFlipCache();\n  }\n\n  // ========================= Align =========================\n  const onAlign = useEvent(() => {\n    if (popupEle && target && open && !mobile) {\n      var _popupElement$parentE, _popupRect$x, _popupRect$y, _popupElement$parentE2;\n      const popupElement = popupEle;\n      const doc = popupElement.ownerDocument;\n      const win = getWin(popupElement);\n      const {\n        position: popupPosition\n      } = win.getComputedStyle(popupElement);\n      const originLeft = popupElement.style.left;\n      const originTop = popupElement.style.top;\n      const originRight = popupElement.style.right;\n      const originBottom = popupElement.style.bottom;\n      const originOverflow = popupElement.style.overflow;\n\n      // Placement\n      const placementInfo = _objectSpread(_objectSpread({}, builtinPlacements[placement]), popupAlign);\n\n      // placeholder element\n      const placeholderElement = doc.createElement('div');\n      (_popupElement$parentE = popupElement.parentElement) === null || _popupElement$parentE === void 0 || _popupElement$parentE.appendChild(placeholderElement);\n      placeholderElement.style.left = \"\".concat(popupElement.offsetLeft, \"px\");\n      placeholderElement.style.top = \"\".concat(popupElement.offsetTop, \"px\");\n      placeholderElement.style.position = popupPosition;\n      placeholderElement.style.height = \"\".concat(popupElement.offsetHeight, \"px\");\n      placeholderElement.style.width = \"\".concat(popupElement.offsetWidth, \"px\");\n\n      // Reset first\n      popupElement.style.left = '0';\n      popupElement.style.top = '0';\n      popupElement.style.right = 'auto';\n      popupElement.style.bottom = 'auto';\n      popupElement.style.overflow = 'hidden';\n\n      // Calculate align style, we should consider `transform` case\n      let targetRect;\n      if (Array.isArray(target)) {\n        targetRect = {\n          x: target[0],\n          y: target[1],\n          width: 0,\n          height: 0\n        };\n      } else {\n        var _rect$x, _rect$y;\n        const rect = target.getBoundingClientRect();\n        rect.x = (_rect$x = rect.x) !== null && _rect$x !== void 0 ? _rect$x : rect.left;\n        rect.y = (_rect$y = rect.y) !== null && _rect$y !== void 0 ? _rect$y : rect.top;\n        targetRect = {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      }\n      const popupRect = popupElement.getBoundingClientRect();\n      const {\n        height,\n        width\n      } = win.getComputedStyle(popupElement);\n      popupRect.x = (_popupRect$x = popupRect.x) !== null && _popupRect$x !== void 0 ? _popupRect$x : popupRect.left;\n      popupRect.y = (_popupRect$y = popupRect.y) !== null && _popupRect$y !== void 0 ? _popupRect$y : popupRect.top;\n      const {\n        clientWidth,\n        clientHeight,\n        scrollWidth,\n        scrollHeight,\n        scrollTop,\n        scrollLeft\n      } = doc.documentElement;\n      const popupHeight = popupRect.height;\n      const popupWidth = popupRect.width;\n      const targetHeight = targetRect.height;\n      const targetWidth = targetRect.width;\n\n      // Get bounding of visible area\n      const visibleRegion = {\n        left: 0,\n        top: 0,\n        right: clientWidth,\n        bottom: clientHeight\n      };\n      const scrollRegion = {\n        left: -scrollLeft,\n        top: -scrollTop,\n        right: scrollWidth - scrollLeft,\n        bottom: scrollHeight - scrollTop\n      };\n      let {\n        htmlRegion\n      } = placementInfo;\n      const VISIBLE = 'visible';\n      const VISIBLE_FIRST = 'visibleFirst';\n      if (htmlRegion !== 'scroll' && htmlRegion !== VISIBLE_FIRST) {\n        htmlRegion = VISIBLE;\n      }\n      const isVisibleFirst = htmlRegion === VISIBLE_FIRST;\n      const scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);\n      const visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);\n      const visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;\n\n      // When set to `visibleFirst`,\n      // the check `adjust` logic will use `visibleRegion` for check first.\n      const adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;\n\n      // Record right & bottom align data\n      popupElement.style.left = 'auto';\n      popupElement.style.top = 'auto';\n      popupElement.style.right = '0';\n      popupElement.style.bottom = '0';\n      const popupMirrorRect = popupElement.getBoundingClientRect();\n\n      // Reset back\n      popupElement.style.left = originLeft;\n      popupElement.style.top = originTop;\n      popupElement.style.right = originRight;\n      popupElement.style.bottom = originBottom;\n      popupElement.style.overflow = originOverflow;\n      (_popupElement$parentE2 = popupElement.parentElement) === null || _popupElement$parentE2 === void 0 || _popupElement$parentE2.removeChild(placeholderElement);\n\n      // Calculate scale\n      const scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1000) / 1000);\n      const scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1000) / 1000);\n\n      // No need to align since it's not visible in view\n      if (scaleX === 0 || scaleY === 0 || isDOM(target) && !isVisible(target)) {\n        return;\n      }\n\n      // Offset\n      const {\n        offset,\n        targetOffset\n      } = placementInfo;\n      let [popupOffsetX, popupOffsetY] = getNumberOffset(popupRect, offset);\n      const [targetOffsetX, targetOffsetY] = getNumberOffset(targetRect, targetOffset);\n      targetRect.x -= targetOffsetX;\n      targetRect.y -= targetOffsetY;\n\n      // Points\n      const [popupPoint, targetPoint] = placementInfo.points || [];\n      const targetPoints = splitPoints(targetPoint);\n      const popupPoints = splitPoints(popupPoint);\n      const targetAlignPoint = getAlignPoint(targetRect, targetPoints);\n      const popupAlignPoint = getAlignPoint(popupRect, popupPoints);\n\n      // Real align info may not same as origin one\n      const nextAlignInfo = _objectSpread({}, placementInfo);\n      let nextPoints = [popupPoints, targetPoints];\n\n      // Next Offset\n      let nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;\n      let nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;\n\n      // ============== Intersection ===============\n      // Get area by position. Used for check if flip area is better\n      function getIntersectionVisibleArea(offsetX, offsetY) {\n        let area = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : visibleArea;\n        const l = popupRect.x + offsetX;\n        const t = popupRect.y + offsetY;\n        const r = l + popupWidth;\n        const b = t + popupHeight;\n        const visibleL = Math.max(l, area.left);\n        const visibleT = Math.max(t, area.top);\n        const visibleR = Math.min(r, area.right);\n        const visibleB = Math.min(b, area.bottom);\n        return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));\n      }\n      const originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);\n\n      // As `visibleFirst`, we prepare this for check\n      const originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);\n\n      // ========================== Overflow ===========================\n      const targetAlignPointTL = getAlignPoint(targetRect, ['t', 'l']);\n      const popupAlignPointTL = getAlignPoint(popupRect, ['t', 'l']);\n      const targetAlignPointBR = getAlignPoint(targetRect, ['b', 'r']);\n      const popupAlignPointBR = getAlignPoint(popupRect, ['b', 'r']);\n      const overflow = placementInfo.overflow || {};\n      const {\n        adjustX,\n        adjustY,\n        shiftX,\n        shiftY\n      } = overflow;\n      const supportAdjust = val => {\n        if (typeof val === 'boolean') {\n          return val;\n        }\n        return val >= 0;\n      };\n\n      // Prepare position\n      let nextPopupY;\n      let nextPopupBottom;\n      let nextPopupX;\n      let nextPopupRight;\n      function syncNextPopupPosition() {\n        nextPopupY = popupRect.y + nextOffsetY;\n        nextPopupBottom = nextPopupY + popupHeight;\n        nextPopupX = popupRect.x + nextOffsetX;\n        nextPopupRight = nextPopupX + popupWidth;\n      }\n      syncNextPopupPosition();\n\n      // >>>>>>>>>> Top & Bottom\n      const needAdjustY = supportAdjust(adjustY);\n      const sameTB = popupPoints[0] === targetPoints[0];\n\n      // Bottom to Top\n      if (needAdjustY && popupPoints[0] === 't' && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {\n        let tmpNextOffsetY = nextOffsetY;\n        if (sameTB) {\n          tmpNextOffsetY -= popupHeight - targetHeight;\n        } else {\n          tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;\n        }\n        const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);\n        const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.bt = true;\n          nextOffsetY = tmpNextOffsetY;\n          popupOffsetY = -popupOffsetY;\n          nextPoints = [reversePoints(nextPoints[0], 0), reversePoints(nextPoints[1], 0)];\n        } else {\n          prevFlipRef.current.bt = false;\n        }\n      }\n\n      // Top to Bottom\n      if (needAdjustY && popupPoints[0] === 'b' && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {\n        let tmpNextOffsetY = nextOffsetY;\n        if (sameTB) {\n          tmpNextOffsetY += popupHeight - targetHeight;\n        } else {\n          tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;\n        }\n        const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);\n        const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.tb = true;\n          nextOffsetY = tmpNextOffsetY;\n          popupOffsetY = -popupOffsetY;\n          nextPoints = [reversePoints(nextPoints[0], 0), reversePoints(nextPoints[1], 0)];\n        } else {\n          prevFlipRef.current.tb = false;\n        }\n      }\n\n      // >>>>>>>>>> Left & Right\n      const needAdjustX = supportAdjust(adjustX);\n\n      // >>>>> Flip\n      const sameLR = popupPoints[1] === targetPoints[1];\n\n      // Right to Left\n      if (needAdjustX && popupPoints[1] === 'l' && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {\n        let tmpNextOffsetX = nextOffsetX;\n        if (sameLR) {\n          tmpNextOffsetX -= popupWidth - targetWidth;\n        } else {\n          tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;\n        }\n        const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);\n        const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.rl = true;\n          nextOffsetX = tmpNextOffsetX;\n          popupOffsetX = -popupOffsetX;\n          nextPoints = [reversePoints(nextPoints[0], 1), reversePoints(nextPoints[1], 1)];\n        } else {\n          prevFlipRef.current.rl = false;\n        }\n      }\n\n      // Left to Right\n      if (needAdjustX && popupPoints[1] === 'r' && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {\n        let tmpNextOffsetX = nextOffsetX;\n        if (sameLR) {\n          tmpNextOffsetX += popupWidth - targetWidth;\n        } else {\n          tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;\n        }\n        const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);\n        const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.lr = true;\n          nextOffsetX = tmpNextOffsetX;\n          popupOffsetX = -popupOffsetX;\n          nextPoints = [reversePoints(nextPoints[0], 1), reversePoints(nextPoints[1], 1)];\n        } else {\n          prevFlipRef.current.lr = false;\n        }\n      }\n      nextAlignInfo.points = [flatPoints(nextPoints[0]), flatPoints(nextPoints[1])];\n\n      // ============================ Shift ============================\n      syncNextPopupPosition();\n      const numShiftX = shiftX === true ? 0 : shiftX;\n      if (typeof numShiftX === 'number') {\n        // Left\n        if (nextPopupX < visibleRegionArea.left) {\n          nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;\n          if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {\n            nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;\n          }\n        }\n\n        // Right\n        if (nextPopupRight > visibleRegionArea.right) {\n          nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;\n          if (targetRect.x > visibleRegionArea.right - numShiftX) {\n            nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;\n          }\n        }\n      }\n      const numShiftY = shiftY === true ? 0 : shiftY;\n      if (typeof numShiftY === 'number') {\n        // Top\n        if (nextPopupY < visibleRegionArea.top) {\n          nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;\n\n          // When target if far away from visible area\n          // Stop shift\n          if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {\n            nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;\n          }\n        }\n\n        // Bottom\n        if (nextPopupBottom > visibleRegionArea.bottom) {\n          nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;\n          if (targetRect.y > visibleRegionArea.bottom - numShiftY) {\n            nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;\n          }\n        }\n      }\n\n      // ============================ Arrow ============================\n      // Arrow center align\n      const popupLeft = popupRect.x + nextOffsetX;\n      const popupRight = popupLeft + popupWidth;\n      const popupTop = popupRect.y + nextOffsetY;\n      const popupBottom = popupTop + popupHeight;\n      const targetLeft = targetRect.x;\n      const targetRight = targetLeft + targetWidth;\n      const targetTop = targetRect.y;\n      const targetBottom = targetTop + targetHeight;\n\n      /** Max left of the popup and target element */\n      const maxLeft = Math.max(popupLeft, targetLeft);\n      /** Min right of the popup and target element */\n      const minRight = Math.min(popupRight, targetRight);\n\n      /** The center X of popup & target cross area */\n      const xCenter = (maxLeft + minRight) / 2;\n      /** Arrow X of popup offset */\n      const nextArrowX = xCenter - popupLeft;\n      const maxTop = Math.max(popupTop, targetTop);\n      const minBottom = Math.min(popupBottom, targetBottom);\n      const yCenter = (maxTop + minBottom) / 2;\n      const nextArrowY = yCenter - popupTop;\n      onPopupAlign === null || onPopupAlign === void 0 || onPopupAlign(popupEle, nextAlignInfo);\n\n      // Additional calculate right & bottom position\n      let offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);\n      let offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);\n      if (scaleX === 1) {\n        nextOffsetX = Math.floor(nextOffsetX);\n        offsetX4Right = Math.floor(offsetX4Right);\n      }\n      if (scaleY === 1) {\n        nextOffsetY = Math.floor(nextOffsetY);\n        offsetY4Bottom = Math.floor(offsetY4Bottom);\n      }\n      const nextOffsetInfo = {\n        ready: true,\n        offsetX: nextOffsetX / scaleX,\n        offsetY: nextOffsetY / scaleY,\n        offsetR: offsetX4Right / scaleX,\n        offsetB: offsetY4Bottom / scaleY,\n        arrowX: nextArrowX / scaleX,\n        arrowY: nextArrowY / scaleY,\n        scaleX,\n        scaleY,\n        align: nextAlignInfo\n      };\n      setOffsetInfo(nextOffsetInfo);\n    }\n  });\n  const triggerAlign = () => {\n    alignCountRef.current += 1;\n    const id = alignCountRef.current;\n\n    // Merge all align requirement into one frame\n    Promise.resolve().then(() => {\n      if (alignCountRef.current === id) {\n        onAlign();\n      }\n    });\n  };\n\n  // Reset ready status when placement & open changed\n  const resetReady = () => {\n    setOffsetInfo(ori => _objectSpread(_objectSpread({}, ori), {}, {\n      ready: false\n    }));\n  };\n  useLayoutEffect(resetReady, [placement]);\n  useLayoutEffect(() => {\n    if (!open) {\n      resetReady();\n    }\n  }, [open]);\n  return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];\n}","map":{"version":3,"names":["isDOM","isVisible","useEvent","useLayoutEffect","React","collectScroller","getVisibleArea","getWin","toNum","getUnitOffset","size","offset","arguments","length","undefined","offsetStr","concat","cells","match","parseFloat","getNumberOffset","rect","offsetX","offsetY","width","height","splitPoints","points","getAlignPoint","topBottom","leftRight","x","y","reversePoints","index","reverseMap","t","b","l","r","clone","flatPoints","join","useAlign","open","popupEle","target","placement","builtinPlacements","popupAlign","onPopupAlign","mobile","offsetInfo","setOffsetInfo","useState","ready","offsetR","offsetB","arrowX","arrowY","scaleX","scaleY","align","alignCountRef","useRef","scrollerList","useMemo","prevFlipRef","resetFlipCache","current","onAlign","_popupElement$parentE","_popupRect$x","_popupRect$y","_popupElement$parentE2","popupElement","doc","ownerDocument","win","position","popupPosition","getComputedStyle","originLeft","style","left","originTop","top","originRight","right","originBottom","bottom","originOverflow","overflow","placementInfo","_objectSpread","placeholderElement","createElement","parentElement","appendChild","offsetLeft","offsetTop","offsetHeight","offsetWidth","targetRect","Array","isArray","_rect$x","_rect$y","getBoundingClientRect","popupRect","clientWidth","clientHeight","scrollWidth","scrollHeight","scrollTop","scrollLeft","documentElement","popupHeight","popupWidth","targetHeight","targetWidth","visibleRegion","scrollRegion","htmlRegion","VISIBLE","VISIBLE_FIRST","isVisibleFirst","scrollRegionArea","visibleRegionArea","visibleArea","adjustCheckVisibleArea","popupMirrorRect","removeChild","Math","round","targetOffset","popupOffsetX","popupOffsetY","targetOffsetX","targetOffsetY","popupPoint","targetPoint","targetPoints","popupPoints","targetAlignPoint","popupAlignPoint","nextAlignInfo","nextPoints","nextOffsetX","nextOffsetY","getIntersectionVisibleArea","area","visibleL","max","visibleT","visibleR","min","visibleB","originIntersectionVisibleArea","originIntersectionRecommendArea","targetAlignPointTL","popupAlignPointTL","targetAlignPointBR","popupAlignPointBR","adjustX","adjustY","shiftX","shiftY","supportAdjust","val","nextPopupY","nextPopupBottom","nextPopupX","nextPopupRight","syncNextPopupPosition","needAdjustY","sameTB","bt","tmpNextOffsetY","newVisibleArea","newVisibleRecommendArea","tb","needAdjustX","sameLR","rl","tmpNextOffsetX","lr","numShiftX","numShiftY","popupLeft","popupRight","popupTop","popupBottom","targetLeft","targetRight","targetTop","targetBottom","maxLeft","minRight","xCenter","nextArrowX","maxTop","minBottom","yCenter","nextArrowY","offsetX4Right","offsetY4Bottom","floor","nextOffsetInfo","triggerAlign","id","Promise","resolve","then","resetReady","ori"],"sources":["/Users/ferncliffadmin/clawd/projects/thesalessherpa/src/client/node_modules/@rc-component/trigger/es/hooks/useAlign.js"],"sourcesContent":["import { isDOM } from \"@rc-component/util/es/Dom/findDOMNode\";\nimport isVisible from \"@rc-component/util/es/Dom/isVisible\";\nimport useEvent from \"@rc-component/util/es/hooks/useEvent\";\nimport useLayoutEffect from \"@rc-component/util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\nimport { collectScroller, getVisibleArea, getWin, toNum } from \"../util\";\nfunction getUnitOffset(size, offset = 0) {\n  const offsetStr = `${offset}`;\n  const cells = offsetStr.match(/^(.*)\\%$/);\n  if (cells) {\n    return size * (parseFloat(cells[1]) / 100);\n  }\n  return parseFloat(offsetStr);\n}\nfunction getNumberOffset(rect, offset) {\n  const [offsetX, offsetY] = offset || [];\n  return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];\n}\nfunction splitPoints(points = '') {\n  return [points[0], points[1]];\n}\nfunction getAlignPoint(rect, points) {\n  const topBottom = points[0];\n  const leftRight = points[1];\n  let x;\n  let y;\n\n  // Top & Bottom\n  if (topBottom === 't') {\n    y = rect.y;\n  } else if (topBottom === 'b') {\n    y = rect.y + rect.height;\n  } else {\n    y = rect.y + rect.height / 2;\n  }\n\n  // Left & Right\n  if (leftRight === 'l') {\n    x = rect.x;\n  } else if (leftRight === 'r') {\n    x = rect.x + rect.width;\n  } else {\n    x = rect.x + rect.width / 2;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction reversePoints(points, index) {\n  const reverseMap = {\n    t: 'b',\n    b: 't',\n    l: 'r',\n    r: 'l'\n  };\n  const clone = [...points];\n  clone[index] = reverseMap[points[index]] || 'c';\n  return clone;\n}\nfunction flatPoints(points) {\n  return points.join('');\n}\nexport default function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign, mobile) {\n  const [offsetInfo, setOffsetInfo] = React.useState({\n    ready: false,\n    offsetX: 0,\n    offsetY: 0,\n    offsetR: 0,\n    offsetB: 0,\n    arrowX: 0,\n    arrowY: 0,\n    scaleX: 1,\n    scaleY: 1,\n    align: builtinPlacements[placement] || {}\n  });\n  const alignCountRef = React.useRef(0);\n  const scrollerList = React.useMemo(() => {\n    if (!popupEle || mobile) {\n      return [];\n    }\n    return collectScroller(popupEle);\n  }, [popupEle]);\n\n  // ========================= Flip ==========================\n  // We will memo flip info.\n  // If size change to make flip, it will memo the flip info and use it in next align.\n  const prevFlipRef = React.useRef({});\n  const resetFlipCache = () => {\n    prevFlipRef.current = {};\n  };\n  if (!open) {\n    resetFlipCache();\n  }\n\n  // ========================= Align =========================\n  const onAlign = useEvent(() => {\n    if (popupEle && target && open && !mobile) {\n      const popupElement = popupEle;\n      const doc = popupElement.ownerDocument;\n      const win = getWin(popupElement);\n      const {\n        position: popupPosition\n      } = win.getComputedStyle(popupElement);\n      const originLeft = popupElement.style.left;\n      const originTop = popupElement.style.top;\n      const originRight = popupElement.style.right;\n      const originBottom = popupElement.style.bottom;\n      const originOverflow = popupElement.style.overflow;\n\n      // Placement\n      const placementInfo = {\n        ...builtinPlacements[placement],\n        ...popupAlign\n      };\n\n      // placeholder element\n      const placeholderElement = doc.createElement('div');\n      popupElement.parentElement?.appendChild(placeholderElement);\n      placeholderElement.style.left = `${popupElement.offsetLeft}px`;\n      placeholderElement.style.top = `${popupElement.offsetTop}px`;\n      placeholderElement.style.position = popupPosition;\n      placeholderElement.style.height = `${popupElement.offsetHeight}px`;\n      placeholderElement.style.width = `${popupElement.offsetWidth}px`;\n\n      // Reset first\n      popupElement.style.left = '0';\n      popupElement.style.top = '0';\n      popupElement.style.right = 'auto';\n      popupElement.style.bottom = 'auto';\n      popupElement.style.overflow = 'hidden';\n\n      // Calculate align style, we should consider `transform` case\n      let targetRect;\n      if (Array.isArray(target)) {\n        targetRect = {\n          x: target[0],\n          y: target[1],\n          width: 0,\n          height: 0\n        };\n      } else {\n        const rect = target.getBoundingClientRect();\n        rect.x = rect.x ?? rect.left;\n        rect.y = rect.y ?? rect.top;\n        targetRect = {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      }\n      const popupRect = popupElement.getBoundingClientRect();\n      const {\n        height,\n        width\n      } = win.getComputedStyle(popupElement);\n      popupRect.x = popupRect.x ?? popupRect.left;\n      popupRect.y = popupRect.y ?? popupRect.top;\n      const {\n        clientWidth,\n        clientHeight,\n        scrollWidth,\n        scrollHeight,\n        scrollTop,\n        scrollLeft\n      } = doc.documentElement;\n      const popupHeight = popupRect.height;\n      const popupWidth = popupRect.width;\n      const targetHeight = targetRect.height;\n      const targetWidth = targetRect.width;\n\n      // Get bounding of visible area\n      const visibleRegion = {\n        left: 0,\n        top: 0,\n        right: clientWidth,\n        bottom: clientHeight\n      };\n      const scrollRegion = {\n        left: -scrollLeft,\n        top: -scrollTop,\n        right: scrollWidth - scrollLeft,\n        bottom: scrollHeight - scrollTop\n      };\n      let {\n        htmlRegion\n      } = placementInfo;\n      const VISIBLE = 'visible';\n      const VISIBLE_FIRST = 'visibleFirst';\n      if (htmlRegion !== 'scroll' && htmlRegion !== VISIBLE_FIRST) {\n        htmlRegion = VISIBLE;\n      }\n      const isVisibleFirst = htmlRegion === VISIBLE_FIRST;\n      const scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);\n      const visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);\n      const visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;\n\n      // When set to `visibleFirst`,\n      // the check `adjust` logic will use `visibleRegion` for check first.\n      const adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;\n\n      // Record right & bottom align data\n      popupElement.style.left = 'auto';\n      popupElement.style.top = 'auto';\n      popupElement.style.right = '0';\n      popupElement.style.bottom = '0';\n      const popupMirrorRect = popupElement.getBoundingClientRect();\n\n      // Reset back\n      popupElement.style.left = originLeft;\n      popupElement.style.top = originTop;\n      popupElement.style.right = originRight;\n      popupElement.style.bottom = originBottom;\n      popupElement.style.overflow = originOverflow;\n      popupElement.parentElement?.removeChild(placeholderElement);\n\n      // Calculate scale\n      const scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1000) / 1000);\n      const scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1000) / 1000);\n\n      // No need to align since it's not visible in view\n      if (scaleX === 0 || scaleY === 0 || isDOM(target) && !isVisible(target)) {\n        return;\n      }\n\n      // Offset\n      const {\n        offset,\n        targetOffset\n      } = placementInfo;\n      let [popupOffsetX, popupOffsetY] = getNumberOffset(popupRect, offset);\n      const [targetOffsetX, targetOffsetY] = getNumberOffset(targetRect, targetOffset);\n      targetRect.x -= targetOffsetX;\n      targetRect.y -= targetOffsetY;\n\n      // Points\n      const [popupPoint, targetPoint] = placementInfo.points || [];\n      const targetPoints = splitPoints(targetPoint);\n      const popupPoints = splitPoints(popupPoint);\n      const targetAlignPoint = getAlignPoint(targetRect, targetPoints);\n      const popupAlignPoint = getAlignPoint(popupRect, popupPoints);\n\n      // Real align info may not same as origin one\n      const nextAlignInfo = {\n        ...placementInfo\n      };\n      let nextPoints = [popupPoints, targetPoints];\n\n      // Next Offset\n      let nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;\n      let nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;\n\n      // ============== Intersection ===============\n      // Get area by position. Used for check if flip area is better\n      function getIntersectionVisibleArea(offsetX, offsetY, area = visibleArea) {\n        const l = popupRect.x + offsetX;\n        const t = popupRect.y + offsetY;\n        const r = l + popupWidth;\n        const b = t + popupHeight;\n        const visibleL = Math.max(l, area.left);\n        const visibleT = Math.max(t, area.top);\n        const visibleR = Math.min(r, area.right);\n        const visibleB = Math.min(b, area.bottom);\n        return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));\n      }\n      const originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);\n\n      // As `visibleFirst`, we prepare this for check\n      const originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);\n\n      // ========================== Overflow ===========================\n      const targetAlignPointTL = getAlignPoint(targetRect, ['t', 'l']);\n      const popupAlignPointTL = getAlignPoint(popupRect, ['t', 'l']);\n      const targetAlignPointBR = getAlignPoint(targetRect, ['b', 'r']);\n      const popupAlignPointBR = getAlignPoint(popupRect, ['b', 'r']);\n      const overflow = placementInfo.overflow || {};\n      const {\n        adjustX,\n        adjustY,\n        shiftX,\n        shiftY\n      } = overflow;\n      const supportAdjust = val => {\n        if (typeof val === 'boolean') {\n          return val;\n        }\n        return val >= 0;\n      };\n\n      // Prepare position\n      let nextPopupY;\n      let nextPopupBottom;\n      let nextPopupX;\n      let nextPopupRight;\n      function syncNextPopupPosition() {\n        nextPopupY = popupRect.y + nextOffsetY;\n        nextPopupBottom = nextPopupY + popupHeight;\n        nextPopupX = popupRect.x + nextOffsetX;\n        nextPopupRight = nextPopupX + popupWidth;\n      }\n      syncNextPopupPosition();\n\n      // >>>>>>>>>> Top & Bottom\n      const needAdjustY = supportAdjust(adjustY);\n      const sameTB = popupPoints[0] === targetPoints[0];\n\n      // Bottom to Top\n      if (needAdjustY && popupPoints[0] === 't' && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {\n        let tmpNextOffsetY = nextOffsetY;\n        if (sameTB) {\n          tmpNextOffsetY -= popupHeight - targetHeight;\n        } else {\n          tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;\n        }\n        const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);\n        const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.bt = true;\n          nextOffsetY = tmpNextOffsetY;\n          popupOffsetY = -popupOffsetY;\n          nextPoints = [reversePoints(nextPoints[0], 0), reversePoints(nextPoints[1], 0)];\n        } else {\n          prevFlipRef.current.bt = false;\n        }\n      }\n\n      // Top to Bottom\n      if (needAdjustY && popupPoints[0] === 'b' && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {\n        let tmpNextOffsetY = nextOffsetY;\n        if (sameTB) {\n          tmpNextOffsetY += popupHeight - targetHeight;\n        } else {\n          tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;\n        }\n        const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);\n        const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.tb = true;\n          nextOffsetY = tmpNextOffsetY;\n          popupOffsetY = -popupOffsetY;\n          nextPoints = [reversePoints(nextPoints[0], 0), reversePoints(nextPoints[1], 0)];\n        } else {\n          prevFlipRef.current.tb = false;\n        }\n      }\n\n      // >>>>>>>>>> Left & Right\n      const needAdjustX = supportAdjust(adjustX);\n\n      // >>>>> Flip\n      const sameLR = popupPoints[1] === targetPoints[1];\n\n      // Right to Left\n      if (needAdjustX && popupPoints[1] === 'l' && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {\n        let tmpNextOffsetX = nextOffsetX;\n        if (sameLR) {\n          tmpNextOffsetX -= popupWidth - targetWidth;\n        } else {\n          tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;\n        }\n        const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);\n        const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.rl = true;\n          nextOffsetX = tmpNextOffsetX;\n          popupOffsetX = -popupOffsetX;\n          nextPoints = [reversePoints(nextPoints[0], 1), reversePoints(nextPoints[1], 1)];\n        } else {\n          prevFlipRef.current.rl = false;\n        }\n      }\n\n      // Left to Right\n      if (needAdjustX && popupPoints[1] === 'r' && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {\n        let tmpNextOffsetX = nextOffsetX;\n        if (sameLR) {\n          tmpNextOffsetX += popupWidth - targetWidth;\n        } else {\n          tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;\n        }\n        const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);\n        const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.lr = true;\n          nextOffsetX = tmpNextOffsetX;\n          popupOffsetX = -popupOffsetX;\n          nextPoints = [reversePoints(nextPoints[0], 1), reversePoints(nextPoints[1], 1)];\n        } else {\n          prevFlipRef.current.lr = false;\n        }\n      }\n      nextAlignInfo.points = [flatPoints(nextPoints[0]), flatPoints(nextPoints[1])];\n\n      // ============================ Shift ============================\n      syncNextPopupPosition();\n      const numShiftX = shiftX === true ? 0 : shiftX;\n      if (typeof numShiftX === 'number') {\n        // Left\n        if (nextPopupX < visibleRegionArea.left) {\n          nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;\n          if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {\n            nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;\n          }\n        }\n\n        // Right\n        if (nextPopupRight > visibleRegionArea.right) {\n          nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;\n          if (targetRect.x > visibleRegionArea.right - numShiftX) {\n            nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;\n          }\n        }\n      }\n      const numShiftY = shiftY === true ? 0 : shiftY;\n      if (typeof numShiftY === 'number') {\n        // Top\n        if (nextPopupY < visibleRegionArea.top) {\n          nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;\n\n          // When target if far away from visible area\n          // Stop shift\n          if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {\n            nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;\n          }\n        }\n\n        // Bottom\n        if (nextPopupBottom > visibleRegionArea.bottom) {\n          nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;\n          if (targetRect.y > visibleRegionArea.bottom - numShiftY) {\n            nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;\n          }\n        }\n      }\n\n      // ============================ Arrow ============================\n      // Arrow center align\n      const popupLeft = popupRect.x + nextOffsetX;\n      const popupRight = popupLeft + popupWidth;\n      const popupTop = popupRect.y + nextOffsetY;\n      const popupBottom = popupTop + popupHeight;\n      const targetLeft = targetRect.x;\n      const targetRight = targetLeft + targetWidth;\n      const targetTop = targetRect.y;\n      const targetBottom = targetTop + targetHeight;\n\n      /** Max left of the popup and target element */\n      const maxLeft = Math.max(popupLeft, targetLeft);\n      /** Min right of the popup and target element */\n      const minRight = Math.min(popupRight, targetRight);\n\n      /** The center X of popup & target cross area */\n      const xCenter = (maxLeft + minRight) / 2;\n      /** Arrow X of popup offset */\n      const nextArrowX = xCenter - popupLeft;\n      const maxTop = Math.max(popupTop, targetTop);\n      const minBottom = Math.min(popupBottom, targetBottom);\n      const yCenter = (maxTop + minBottom) / 2;\n      const nextArrowY = yCenter - popupTop;\n      onPopupAlign?.(popupEle, nextAlignInfo);\n\n      // Additional calculate right & bottom position\n      let offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);\n      let offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);\n      if (scaleX === 1) {\n        nextOffsetX = Math.floor(nextOffsetX);\n        offsetX4Right = Math.floor(offsetX4Right);\n      }\n      if (scaleY === 1) {\n        nextOffsetY = Math.floor(nextOffsetY);\n        offsetY4Bottom = Math.floor(offsetY4Bottom);\n      }\n      const nextOffsetInfo = {\n        ready: true,\n        offsetX: nextOffsetX / scaleX,\n        offsetY: nextOffsetY / scaleY,\n        offsetR: offsetX4Right / scaleX,\n        offsetB: offsetY4Bottom / scaleY,\n        arrowX: nextArrowX / scaleX,\n        arrowY: nextArrowY / scaleY,\n        scaleX,\n        scaleY,\n        align: nextAlignInfo\n      };\n      setOffsetInfo(nextOffsetInfo);\n    }\n  });\n  const triggerAlign = () => {\n    alignCountRef.current += 1;\n    const id = alignCountRef.current;\n\n    // Merge all align requirement into one frame\n    Promise.resolve().then(() => {\n      if (alignCountRef.current === id) {\n        onAlign();\n      }\n    });\n  };\n\n  // Reset ready status when placement & open changed\n  const resetReady = () => {\n    setOffsetInfo(ori => ({\n      ...ori,\n      ready: false\n    }));\n  };\n  useLayoutEffect(resetReady, [placement]);\n  useLayoutEffect(() => {\n    if (!open) {\n      resetReady();\n    }\n  }, [open]);\n  return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}