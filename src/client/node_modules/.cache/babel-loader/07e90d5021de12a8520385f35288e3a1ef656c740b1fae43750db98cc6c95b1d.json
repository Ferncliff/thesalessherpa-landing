{"ast":null,"code":"import _objectSpread from \"/Users/ferncliffadmin/clawd/projects/thesalessherpa/src/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/ferncliffadmin/clawd/projects/thesalessherpa/src/client/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _defineProperty from \"/Users/ferncliffadmin/clawd/projects/thesalessherpa/src/client/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nconst _excluded = [\"name\"];\nimport { merge } from \"@rc-component/util/es/utils/set\";\nimport { mergeWith } from '@rc-component/util';\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { HOOK_MARK } from \"../FieldContext\";\nimport { allPromiseFinish } from \"../utils/asyncUtil\";\nimport { defaultValidateMessages } from \"../utils/messages\";\nimport NameMap from \"../utils/NameMap\";\nimport { cloneByNamePathList, containsNamePath, getNamePath, getValue, matchNamePath, setValue } from \"../utils/valueUtil\";\nimport WatcherCenter from \"./useNotifyWatch\";\nexport class FormStore {\n  constructor(forceRootUpdate) {\n    var _this = this;\n    _defineProperty(this, \"formHooked\", false);\n    _defineProperty(this, \"forceRootUpdate\", void 0);\n    _defineProperty(this, \"subscribable\", true);\n    _defineProperty(this, \"store\", {});\n    _defineProperty(this, \"fieldEntities\", []);\n    _defineProperty(this, \"initialValues\", {});\n    _defineProperty(this, \"callbacks\", {});\n    _defineProperty(this, \"validateMessages\", null);\n    _defineProperty(this, \"preserve\", null);\n    _defineProperty(this, \"lastValidatePromise\", null);\n    _defineProperty(this, \"watcherCenter\", new WatcherCenter(this));\n    _defineProperty(this, \"getForm\", () => ({\n      getFieldValue: this.getFieldValue,\n      getFieldsValue: this.getFieldsValue,\n      getFieldError: this.getFieldError,\n      getFieldWarning: this.getFieldWarning,\n      getFieldsError: this.getFieldsError,\n      isFieldsTouched: this.isFieldsTouched,\n      isFieldTouched: this.isFieldTouched,\n      isFieldValidating: this.isFieldValidating,\n      isFieldsValidating: this.isFieldsValidating,\n      resetFields: this.resetFields,\n      setFields: this.setFields,\n      setFieldValue: this.setFieldValue,\n      setFieldsValue: this.setFieldsValue,\n      validateFields: this.validateFields,\n      submit: this.submit,\n      _init: true,\n      getInternalHooks: this.getInternalHooks\n    }));\n    // ======================== Internal Hooks ========================\n    _defineProperty(this, \"getInternalHooks\", key => {\n      if (key === HOOK_MARK) {\n        this.formHooked = true;\n        return {\n          dispatch: this.dispatch,\n          initEntityValue: this.initEntityValue,\n          registerField: this.registerField,\n          useSubscribe: this.useSubscribe,\n          setInitialValues: this.setInitialValues,\n          destroyForm: this.destroyForm,\n          setCallbacks: this.setCallbacks,\n          setValidateMessages: this.setValidateMessages,\n          getFields: this.getFields,\n          setPreserve: this.setPreserve,\n          getInitialValue: this.getInitialValue,\n          registerWatch: this.registerWatch\n        };\n      }\n      warning(false, '`getInternalHooks` is internal usage. Should not call directly.');\n      return null;\n    });\n    _defineProperty(this, \"useSubscribe\", subscribable => {\n      this.subscribable = subscribable;\n    });\n    /**\n     * Record prev Form unmount fieldEntities which config preserve false.\n     * This need to be refill with initialValues instead of store value.\n     */\n    _defineProperty(this, \"prevWithoutPreserves\", null);\n    /**\n     * First time `setInitialValues` should update store with initial value\n     */\n    _defineProperty(this, \"setInitialValues\", (initialValues, init) => {\n      this.initialValues = initialValues || {};\n      if (init) {\n        var _this$prevWithoutPres;\n        let nextStore = merge(initialValues, this.store);\n\n        // We will take consider prev form unmount fields.\n        // When the field is not `preserve`, we need fill this with initialValues instead of store.\n        // eslint-disable-next-line array-callback-return\n        (_this$prevWithoutPres = this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 || _this$prevWithoutPres.map(_ref => {\n          let {\n            key: namePath\n          } = _ref;\n          nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));\n        });\n        this.prevWithoutPreserves = null;\n        this.updateStore(nextStore);\n      }\n    });\n    _defineProperty(this, \"destroyForm\", clearOnDestroy => {\n      if (clearOnDestroy) {\n        // destroy form reset store\n        this.updateStore({});\n      } else {\n        // Fill preserve fields\n        const prevWithoutPreserves = new NameMap();\n        this.getFieldEntities(true).forEach(entity => {\n          if (!this.isMergedPreserve(entity.isPreserve())) {\n            prevWithoutPreserves.set(entity.getNamePath(), true);\n          }\n        });\n        this.prevWithoutPreserves = prevWithoutPreserves;\n      }\n    });\n    _defineProperty(this, \"getInitialValue\", namePath => {\n      const initValue = getValue(this.initialValues, namePath);\n\n      // Not cloneDeep when without `namePath`\n      return namePath.length ? merge(initValue) : initValue;\n    });\n    _defineProperty(this, \"setCallbacks\", callbacks => {\n      this.callbacks = callbacks;\n    });\n    _defineProperty(this, \"setValidateMessages\", validateMessages => {\n      this.validateMessages = validateMessages;\n    });\n    _defineProperty(this, \"setPreserve\", preserve => {\n      this.preserve = preserve;\n    });\n    // ============================= Watch ============================\n    _defineProperty(this, \"registerWatch\", callback => {\n      return this.watcherCenter.register(callback);\n    });\n    _defineProperty(this, \"notifyWatch\", function () {\n      let namePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      _this.watcherCenter.notify(namePath);\n    });\n    // ========================== Dev Warning =========================\n    _defineProperty(this, \"timeoutId\", null);\n    _defineProperty(this, \"warningUnhooked\", () => {\n      if (process.env.NODE_ENV !== 'production' && !this.timeoutId && typeof window !== 'undefined') {\n        this.timeoutId = setTimeout(() => {\n          this.timeoutId = null;\n          if (!this.formHooked) {\n            warning(false, 'Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?');\n          }\n        });\n      }\n    });\n    // ============================ Store =============================\n    _defineProperty(this, \"updateStore\", nextStore => {\n      this.store = nextStore;\n    });\n    // ============================ Fields ============================\n    /**\n     * Get registered field entities.\n     * @param pure Only return field which has a `name`. Default: false\n     */\n    _defineProperty(this, \"getFieldEntities\", function () {\n      let pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (!pure) {\n        return _this.fieldEntities;\n      }\n      return _this.fieldEntities.filter(field => field.getNamePath().length);\n    });\n    /**\n     * Get a map of registered field entities with their name path as the key.\n     * @param pure Only include fields which have a `name`. Default: false\n     * @returns A NameMap containing field entities indexed by their name paths\n     */\n    _defineProperty(this, \"getFieldsMap\", function () {\n      let pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      const cache = new NameMap();\n      _this.getFieldEntities(pure).forEach(field => {\n        const namePath = field.getNamePath();\n        cache.set(namePath, field);\n      });\n      return cache;\n    });\n    /**\n     * Get field entities based on a list of name paths.\n     * @param nameList - Array of name paths to search for. If not provided, returns all field entities with names.\n     * @param includesSubNamePath - Whether to include fields that have the given name path as a prefix.\n     */\n    _defineProperty(this, \"getFieldEntitiesForNamePathList\", function (nameList) {\n      let includesSubNamePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (!nameList) {\n        return _this.getFieldEntities(true);\n      }\n      const cache = _this.getFieldsMap(true);\n      if (!includesSubNamePath) {\n        return nameList.map(name => {\n          const namePath = getNamePath(name);\n          return cache.get(namePath) || {\n            INVALIDATE_NAME_PATH: getNamePath(name)\n          };\n        });\n      }\n      return nameList.flatMap(name => {\n        const namePath = getNamePath(name);\n        const fields = cache.getAsPrefix(namePath);\n        if (fields.length) {\n          return fields;\n        }\n        return [{\n          INVALIDATE_NAME_PATH: namePath\n        }];\n      });\n    });\n    _defineProperty(this, \"getFieldsValue\", (nameList, filterFunc) => {\n      this.warningUnhooked();\n\n      // Fill args\n      let mergedNameList;\n      let mergedFilterFunc;\n      if (nameList === true || Array.isArray(nameList)) {\n        mergedNameList = nameList;\n        mergedFilterFunc = filterFunc;\n      } else if (nameList && typeof nameList === 'object') {\n        mergedFilterFunc = nameList.filter;\n      }\n      if (mergedNameList === true && !mergedFilterFunc) {\n        return this.store;\n      }\n      const fieldEntities = this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null, true);\n      const filteredNameList = [];\n      const listNamePaths = [];\n      fieldEntities.forEach(entity => {\n        var _entity$isList;\n        const namePath = entity.INVALIDATE_NAME_PATH || entity.getNamePath();\n\n        // Ignore when it's a list item and not specific the namePath,\n        // since parent field is already take in count\n        if ((_entity$isList = entity.isList) !== null && _entity$isList !== void 0 && _entity$isList.call(entity)) {\n          listNamePaths.push(namePath);\n          return;\n        }\n        if (!mergedFilterFunc) {\n          filteredNameList.push(namePath);\n        } else {\n          const meta = 'getMeta' in entity ? entity.getMeta() : null;\n          if (mergedFilterFunc(meta)) {\n            filteredNameList.push(namePath);\n          }\n        }\n      });\n      let mergedValues = cloneByNamePathList(this.store, filteredNameList.map(getNamePath));\n\n      // We need fill the list as [] if Form.List is empty\n      listNamePaths.forEach(namePath => {\n        if (!getValue(mergedValues, namePath)) {\n          mergedValues = setValue(mergedValues, namePath, []);\n        }\n      });\n      return mergedValues;\n    });\n    _defineProperty(this, \"getFieldValue\", name => {\n      this.warningUnhooked();\n      const namePath = getNamePath(name);\n      return getValue(this.store, namePath);\n    });\n    _defineProperty(this, \"getFieldsError\", nameList => {\n      this.warningUnhooked();\n      const fieldEntities = this.getFieldEntitiesForNamePathList(nameList);\n      return fieldEntities.map((entity, index) => {\n        if (entity && !entity.INVALIDATE_NAME_PATH) {\n          return {\n            name: entity.getNamePath(),\n            errors: entity.getErrors(),\n            warnings: entity.getWarnings()\n          };\n        }\n        return {\n          name: getNamePath(nameList[index]),\n          errors: [],\n          warnings: []\n        };\n      });\n    });\n    _defineProperty(this, \"getFieldError\", name => {\n      this.warningUnhooked();\n      const namePath = getNamePath(name);\n      const fieldError = this.getFieldsError([namePath])[0];\n      return fieldError.errors;\n    });\n    _defineProperty(this, \"getFieldWarning\", name => {\n      this.warningUnhooked();\n      const namePath = getNamePath(name);\n      const fieldError = this.getFieldsError([namePath])[0];\n      return fieldError.warnings;\n    });\n    _defineProperty(this, \"isFieldsTouched\", function () {\n      _this.warningUnhooked();\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const [arg0, arg1] = args;\n      let namePathList;\n      let isAllFieldsTouched = false;\n      if (args.length === 0) {\n        namePathList = null;\n      } else if (args.length === 1) {\n        if (Array.isArray(arg0)) {\n          namePathList = arg0.map(getNamePath);\n          isAllFieldsTouched = false;\n        } else {\n          namePathList = null;\n          isAllFieldsTouched = arg0;\n        }\n      } else {\n        namePathList = arg0.map(getNamePath);\n        isAllFieldsTouched = arg1;\n      }\n      const fieldEntities = _this.getFieldEntities(true);\n      const isFieldTouched = field => field.isFieldTouched();\n\n      // ===== Will get fully compare when not config namePathList =====\n      if (!namePathList) {\n        return isAllFieldsTouched ? fieldEntities.every(entity => isFieldTouched(entity) || entity.isList()) : fieldEntities.some(isFieldTouched);\n      }\n\n      // Generate a nest tree for validate\n      const map = new NameMap();\n      namePathList.forEach(shortNamePath => {\n        map.set(shortNamePath, []);\n      });\n      fieldEntities.forEach(field => {\n        const fieldNamePath = field.getNamePath();\n\n        // Find matched entity and put into list\n        namePathList.forEach(shortNamePath => {\n          if (shortNamePath.every((nameUnit, i) => fieldNamePath[i] === nameUnit)) {\n            map.update(shortNamePath, list => [...list, field]);\n          }\n        });\n      });\n\n      // Check if NameMap value is touched\n      const isNamePathListTouched = entities => entities.some(isFieldTouched);\n      const namePathListEntities = map.map(_ref2 => {\n        let {\n          value\n        } = _ref2;\n        return value;\n      });\n      return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);\n    });\n    _defineProperty(this, \"isFieldTouched\", name => {\n      this.warningUnhooked();\n      return this.isFieldsTouched([name]);\n    });\n    _defineProperty(this, \"isFieldsValidating\", nameList => {\n      this.warningUnhooked();\n      const fieldEntities = this.getFieldEntities();\n      if (!nameList) {\n        return fieldEntities.some(testField => testField.isFieldValidating());\n      }\n      const namePathList = nameList.map(getNamePath);\n      return fieldEntities.some(testField => {\n        const fieldNamePath = testField.getNamePath();\n        return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();\n      });\n    });\n    _defineProperty(this, \"isFieldValidating\", name => {\n      this.warningUnhooked();\n      return this.isFieldsValidating([name]);\n    });\n    /**\n     * Reset Field with field `initialValue` prop.\n     * Can pass `entities` or `namePathList` or just nothing.\n     */\n    _defineProperty(this, \"resetWithFieldInitialValue\", function () {\n      let info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // Create cache\n      const cache = new NameMap();\n      const fieldEntities = _this.getFieldEntities(true);\n      fieldEntities.forEach(field => {\n        const {\n          initialValue\n        } = field.props;\n        const namePath = field.getNamePath();\n\n        // Record only if has `initialValue`\n        if (initialValue !== undefined) {\n          const records = cache.get(namePath) || new Set();\n          records.add({\n            entity: field,\n            value: initialValue\n          });\n          cache.set(namePath, records);\n        }\n      });\n\n      // Reset\n      const resetWithFields = entities => {\n        entities.forEach(field => {\n          const {\n            initialValue\n          } = field.props;\n          if (initialValue !== undefined) {\n            const namePath = field.getNamePath();\n            const formInitialValue = _this.getInitialValue(namePath);\n            if (formInitialValue !== undefined) {\n              // Warning if conflict with form initialValues and do not modify value\n              warning(false, \"Form already set 'initialValues' with path '\".concat(namePath.join('.'), \"'. Field can not overwrite it.\"));\n            } else {\n              const records = cache.get(namePath);\n              if (records && records.size > 1) {\n                // Warning if multiple field set `initialValue`and do not modify value\n                warning(false, \"Multiple Field with path '\".concat(namePath.join('.'), \"' set 'initialValue'. Can not decide which one to pick.\"));\n              } else if (records) {\n                const originValue = _this.getFieldValue(namePath);\n                const isListField = field.isListField();\n\n                // Set `initialValue`\n                if (!isListField && (!info.skipExist || originValue === undefined)) {\n                  _this.updateStore(setValue(_this.store, namePath, [...records][0].value));\n                }\n              }\n            }\n          }\n        });\n      };\n      let requiredFieldEntities;\n      if (info.entities) {\n        requiredFieldEntities = info.entities;\n      } else if (info.namePathList) {\n        requiredFieldEntities = [];\n        info.namePathList.forEach(namePath => {\n          const records = cache.get(namePath);\n          if (records) {\n            requiredFieldEntities.push(...[...records].map(r => r.entity));\n          }\n        });\n      } else {\n        requiredFieldEntities = fieldEntities;\n      }\n      resetWithFields(requiredFieldEntities);\n    });\n    _defineProperty(this, \"resetFields\", nameList => {\n      this.warningUnhooked();\n      const prevStore = this.store;\n      if (!nameList) {\n        this.updateStore(merge(this.initialValues));\n        this.resetWithFieldInitialValue();\n        this.notifyObservers(prevStore, null, {\n          type: 'reset'\n        });\n        this.notifyWatch();\n        return;\n      }\n\n      // Reset by `nameList`\n      const namePathList = nameList.map(getNamePath);\n      namePathList.forEach(namePath => {\n        const initialValue = this.getInitialValue(namePath);\n        this.updateStore(setValue(this.store, namePath, initialValue));\n      });\n      this.resetWithFieldInitialValue({\n        namePathList\n      });\n      this.notifyObservers(prevStore, namePathList, {\n        type: 'reset'\n      });\n      this.notifyWatch(namePathList);\n    });\n    _defineProperty(this, \"setFields\", fields => {\n      this.warningUnhooked();\n      const prevStore = this.store;\n      const namePathList = [];\n      fields.forEach(fieldData => {\n        const {\n            name\n          } = fieldData,\n          data = _objectWithoutProperties(fieldData, _excluded);\n        const namePath = getNamePath(name);\n        namePathList.push(namePath);\n\n        // Value\n        if ('value' in data) {\n          this.updateStore(setValue(this.store, namePath, data.value));\n        }\n        this.notifyObservers(prevStore, [namePath], {\n          type: 'setField',\n          data: fieldData\n        });\n      });\n      this.notifyWatch(namePathList);\n    });\n    _defineProperty(this, \"getFields\", () => {\n      const entities = this.getFieldEntities(true);\n      const fields = entities.map(field => {\n        const namePath = field.getNamePath();\n        const meta = field.getMeta();\n        const fieldData = _objectSpread(_objectSpread({}, meta), {}, {\n          name: namePath,\n          value: this.getFieldValue(namePath)\n        });\n        Object.defineProperty(fieldData, 'originRCField', {\n          value: true\n        });\n        return fieldData;\n      });\n      return fields;\n    });\n    // =========================== Observer ===========================\n    /**\n     * This only trigger when a field is on constructor to avoid we get initialValue too late\n     */\n    _defineProperty(this, \"initEntityValue\", entity => {\n      const {\n        initialValue\n      } = entity.props;\n      if (initialValue !== undefined) {\n        const namePath = entity.getNamePath();\n        const prevValue = getValue(this.store, namePath);\n        if (prevValue === undefined) {\n          this.updateStore(setValue(this.store, namePath, initialValue));\n        }\n      }\n    });\n    _defineProperty(this, \"isMergedPreserve\", fieldPreserve => {\n      const mergedPreserve = fieldPreserve !== undefined ? fieldPreserve : this.preserve;\n      return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;\n    });\n    _defineProperty(this, \"registerField\", entity => {\n      this.fieldEntities.push(entity);\n      const namePath = entity.getNamePath();\n      this.notifyWatch([namePath]);\n\n      // Set initial values\n      if (entity.props.initialValue !== undefined) {\n        const prevStore = this.store;\n        this.resetWithFieldInitialValue({\n          entities: [entity],\n          skipExist: true\n        });\n        this.notifyObservers(prevStore, [entity.getNamePath()], {\n          type: 'valueUpdate',\n          source: 'internal'\n        });\n      }\n\n      // un-register field callback\n      return function (isListField, preserve) {\n        let subNamePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n        _this.fieldEntities = _this.fieldEntities.filter(item => item !== entity);\n\n        // Clean up store value if not preserve\n        if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {\n          const defaultValue = isListField ? undefined : _this.getInitialValue(namePath);\n          if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(field =>\n          // Only reset when no namePath exist\n          !matchNamePath(field.getNamePath(), namePath))) {\n            const prevStore = _this.store;\n            _this.updateStore(setValue(prevStore, namePath, defaultValue, true));\n\n            // Notify that field is unmount\n            _this.notifyObservers(prevStore, [namePath], {\n              type: 'remove'\n            });\n\n            // Dependencies update\n            _this.triggerDependenciesUpdate(prevStore, namePath);\n          }\n        }\n        _this.notifyWatch([namePath]);\n      };\n    });\n    _defineProperty(this, \"dispatch\", action => {\n      switch (action.type) {\n        case 'updateValue':\n          {\n            const {\n              namePath,\n              value\n            } = action;\n            this.updateValue(namePath, value);\n            break;\n          }\n        case 'validateField':\n          {\n            const {\n              namePath,\n              triggerName\n            } = action;\n            this.validateFields([namePath], {\n              triggerName\n            });\n            break;\n          }\n        default:\n        // Currently we don't have other action. Do nothing.\n      }\n    });\n    _defineProperty(this, \"notifyObservers\", (prevStore, namePathList, info) => {\n      if (this.subscribable) {\n        const mergedInfo = _objectSpread(_objectSpread({}, info), {}, {\n          store: this.getFieldsValue(true)\n        });\n        this.getFieldEntities().forEach(_ref3 => {\n          let {\n            onStoreChange\n          } = _ref3;\n          onStoreChange(prevStore, namePathList, mergedInfo);\n        });\n      } else {\n        this.forceRootUpdate();\n      }\n    });\n    /**\n     * Notify dependencies children with parent update\n     * We need delay to trigger validate in case Field is under render props\n     */\n    _defineProperty(this, \"triggerDependenciesUpdate\", (prevStore, namePath) => {\n      const childrenFields = this.getDependencyChildrenFields(namePath);\n      if (childrenFields.length) {\n        this.validateFields(childrenFields);\n      }\n      this.notifyObservers(prevStore, childrenFields, {\n        type: 'dependenciesUpdate',\n        relatedFields: [namePath, ...childrenFields]\n      });\n      return childrenFields;\n    });\n    _defineProperty(this, \"updateValue\", (name, value) => {\n      const namePath = getNamePath(name);\n      const prevStore = this.store;\n      this.updateStore(setValue(this.store, namePath, value));\n      this.notifyObservers(prevStore, [namePath], {\n        type: 'valueUpdate',\n        source: 'internal'\n      });\n      this.notifyWatch([namePath]);\n\n      // Dependencies update\n      const childrenFields = this.triggerDependenciesUpdate(prevStore, namePath);\n\n      // trigger callback function\n      const {\n        onValuesChange\n      } = this.callbacks;\n      if (onValuesChange) {\n        const fieldEntity = this.getFieldsMap(true).get(namePath);\n        const changedValues = cloneByNamePathList(this.store, [namePath]);\n        const allValues = this.getFieldsValue();\n        // Merge changedValues into allValues to ensure allValues contains the latest changes\n        const mergedAllValues = mergeWith([allValues, changedValues], {\n          // When value is array, it means trigger by Form.List which should replace directly\n          prepareArray: current => fieldEntity !== null && fieldEntity !== void 0 && fieldEntity.isList() ? [] : [...(current || [])]\n        });\n        onValuesChange(changedValues, mergedAllValues);\n      }\n      this.triggerOnFieldsChange([namePath, ...childrenFields]);\n    });\n    // Let all child Field get update.\n    _defineProperty(this, \"setFieldsValue\", store => {\n      this.warningUnhooked();\n      const prevStore = this.store;\n      if (store) {\n        const nextStore = merge(this.store, store);\n        this.updateStore(nextStore);\n      }\n      this.notifyObservers(prevStore, null, {\n        type: 'valueUpdate',\n        source: 'external'\n      });\n      this.notifyWatch();\n    });\n    _defineProperty(this, \"setFieldValue\", (name, value) => {\n      this.setFields([{\n        name,\n        value,\n        errors: [],\n        warnings: [],\n        touched: true\n      }]);\n    });\n    _defineProperty(this, \"getDependencyChildrenFields\", rootNamePath => {\n      const children = new Set();\n      const childrenFields = [];\n      const dependencies2fields = new NameMap();\n\n      /**\n       * Generate maps\n       * Can use cache to save perf if user report performance issue with this\n       */\n      this.getFieldEntities().forEach(field => {\n        const {\n          dependencies\n        } = field.props;\n        (dependencies || []).forEach(dependency => {\n          const dependencyNamePath = getNamePath(dependency);\n          dependencies2fields.update(dependencyNamePath, function () {\n            let fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Set();\n            fields.add(field);\n            return fields;\n          });\n        });\n      });\n      const fillChildren = namePath => {\n        const fields = dependencies2fields.get(namePath) || new Set();\n        fields.forEach(field => {\n          if (!children.has(field)) {\n            children.add(field);\n            const fieldNamePath = field.getNamePath();\n            if (field.isFieldDirty() && fieldNamePath.length) {\n              childrenFields.push(fieldNamePath);\n              fillChildren(fieldNamePath);\n            }\n          }\n        });\n      };\n      fillChildren(rootNamePath);\n      return childrenFields;\n    });\n    _defineProperty(this, \"triggerOnFieldsChange\", (namePathList, filedErrors) => {\n      const {\n        onFieldsChange\n      } = this.callbacks;\n      if (onFieldsChange) {\n        const fields = this.getFields();\n\n        /**\n         * Fill errors since `fields` may be replaced by controlled fields\n         */\n        if (filedErrors) {\n          const cache = new NameMap();\n          filedErrors.forEach(_ref4 => {\n            let {\n              name,\n              errors\n            } = _ref4;\n            cache.set(name, errors);\n          });\n          fields.forEach(field => {\n            // eslint-disable-next-line no-param-reassign\n            field.errors = cache.get(field.name) || field.errors;\n          });\n        }\n        const changedFields = fields.filter(_ref5 => {\n          let {\n            name: fieldName\n          } = _ref5;\n          return containsNamePath(namePathList, fieldName);\n        });\n        if (changedFields.length) {\n          onFieldsChange(changedFields, fields);\n        }\n      }\n    });\n    // =========================== Validate ===========================\n    _defineProperty(this, \"validateFields\", (arg1, arg2) => {\n      this.warningUnhooked();\n      let nameList;\n      let options;\n      if (Array.isArray(arg1) || typeof arg1 === 'string' || typeof arg2 === 'string') {\n        nameList = arg1;\n        options = arg2;\n      } else {\n        options = arg1;\n      }\n      const provideNameList = !!nameList;\n      const namePathList = provideNameList ? nameList.map(getNamePath) : [];\n      // Same namePathList, but does not include Form.List name\n      const finalValueNamePathList = [...namePathList];\n\n      // Collect result in promise list\n      const promiseList = [];\n\n      // We temp save the path which need trigger for `onFieldsChange`\n      const TMP_SPLIT = String(Date.now());\n      const validateNamePathList = new Set();\n      const {\n        recursive,\n        dirty\n      } = options || {};\n      this.getFieldEntities(true).forEach(field => {\n        const fieldNamePath = field.getNamePath();\n\n        // Add field if not provide `nameList`\n        if (!provideNameList) {\n          if (\n          // If is field, pass directly\n          !field.isList() ||\n          // If is list, do not add if already exist sub field in the namePathList\n          !namePathList.some(name => matchNamePath(name, fieldNamePath, true))) {\n            finalValueNamePathList.push(fieldNamePath);\n          }\n          namePathList.push(fieldNamePath);\n        }\n\n        // Skip if without rule\n        if (!field.props.rules || !field.props.rules.length) {\n          return;\n        }\n\n        // Skip if only validate dirty field\n        if (dirty && !field.isFieldDirty()) {\n          return;\n        }\n        validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));\n\n        // Add field validate rule in to promise list\n        if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {\n          const promise = field.validateRules(_objectSpread({\n            validateMessages: _objectSpread(_objectSpread({}, defaultValidateMessages), this.validateMessages)\n          }, options));\n\n          // Wrap promise with field\n          promiseList.push(promise.then(() => ({\n            name: fieldNamePath,\n            errors: [],\n            warnings: []\n          })).catch(ruleErrors => {\n            var _ruleErrors$forEach;\n            const mergedErrors = [];\n            const mergedWarnings = [];\n            (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 || _ruleErrors$forEach.call(ruleErrors, _ref6 => {\n              let {\n                rule: {\n                  warningOnly\n                },\n                errors\n              } = _ref6;\n              if (warningOnly) {\n                mergedWarnings.push(...errors);\n              } else {\n                mergedErrors.push(...errors);\n              }\n            });\n            if (mergedErrors.length) {\n              return Promise.reject({\n                name: fieldNamePath,\n                errors: mergedErrors,\n                warnings: mergedWarnings\n              });\n            }\n            return {\n              name: fieldNamePath,\n              errors: mergedErrors,\n              warnings: mergedWarnings\n            };\n          }));\n        }\n      });\n      const summaryPromise = allPromiseFinish(promiseList);\n      this.lastValidatePromise = summaryPromise;\n\n      // Notify fields with rule that validate has finished and need update\n      summaryPromise.catch(results => results).then(results => {\n        const resultNamePathList = results.map(_ref7 => {\n          let {\n            name\n          } = _ref7;\n          return name;\n        });\n        this.notifyObservers(this.store, resultNamePathList, {\n          type: 'validateFinish'\n        });\n        this.triggerOnFieldsChange(resultNamePathList, results);\n      });\n      const returnPromise = summaryPromise.then(() => {\n        if (this.lastValidatePromise === summaryPromise) {\n          return Promise.resolve(this.getFieldsValue(finalValueNamePathList));\n        }\n        return Promise.reject([]);\n      }).catch(results => {\n        var _errorList$;\n        const errorList = results.filter(result => result && result.errors.length);\n        const errorMessage = (_errorList$ = errorList[0]) === null || _errorList$ === void 0 || (_errorList$ = _errorList$.errors) === null || _errorList$ === void 0 ? void 0 : _errorList$[0];\n        return Promise.reject({\n          message: errorMessage,\n          values: this.getFieldsValue(namePathList),\n          errorFields: errorList,\n          outOfDate: this.lastValidatePromise !== summaryPromise\n        });\n      });\n\n      // Do not throw in console\n      returnPromise.catch(e => e);\n\n      // `validating` changed. Trigger `onFieldsChange`\n      const triggerNamePathList = namePathList.filter(namePath => validateNamePathList.has(namePath.join(TMP_SPLIT)));\n      this.triggerOnFieldsChange(triggerNamePathList);\n      return returnPromise;\n    });\n    // ============================ Submit ============================\n    _defineProperty(this, \"submit\", () => {\n      this.warningUnhooked();\n      this.validateFields().then(values => {\n        const {\n          onFinish\n        } = this.callbacks;\n        if (onFinish) {\n          try {\n            onFinish(values);\n          } catch (err) {\n            // Should print error if user `onFinish` callback failed\n            console.error(err);\n          }\n        }\n      }).catch(e => {\n        const {\n          onFinishFailed\n        } = this.callbacks;\n        if (onFinishFailed) {\n          onFinishFailed(e);\n        }\n      });\n    });\n    this.forceRootUpdate = forceRootUpdate;\n  }\n}\nfunction useForm(form) {\n  const formRef = React.useRef(null);\n  const [, forceUpdate] = React.useState({});\n\n  // Create singleton FormStore\n  if (!formRef.current) {\n    if (form) {\n      formRef.current = form;\n    } else {\n      // Create a new FormStore if not provided\n      const forceReRender = () => {\n        forceUpdate({});\n      };\n      const formStore = new FormStore(forceReRender);\n      formRef.current = formStore.getForm();\n    }\n  }\n  return [formRef.current];\n}\nexport default useForm;","map":{"version":3,"names":["merge","mergeWith","warning","React","HOOK_MARK","allPromiseFinish","defaultValidateMessages","NameMap","cloneByNamePathList","containsNamePath","getNamePath","getValue","matchNamePath","setValue","WatcherCenter","FormStore","constructor","forceRootUpdate","_this","_defineProperty","getFieldValue","getFieldsValue","getFieldError","getFieldWarning","getFieldsError","isFieldsTouched","isFieldTouched","isFieldValidating","isFieldsValidating","resetFields","setFields","setFieldValue","setFieldsValue","validateFields","submit","_init","getInternalHooks","key","formHooked","dispatch","initEntityValue","registerField","useSubscribe","setInitialValues","destroyForm","setCallbacks","setValidateMessages","getFields","setPreserve","getInitialValue","registerWatch","subscribable","initialValues","init","_this$prevWithoutPres","nextStore","store","prevWithoutPreserves","map","_ref","namePath","updateStore","clearOnDestroy","getFieldEntities","forEach","entity","isMergedPreserve","isPreserve","set","initValue","length","callbacks","validateMessages","preserve","callback","watcherCenter","register","arguments","undefined","notify","process","env","NODE_ENV","timeoutId","window","setTimeout","pure","fieldEntities","filter","field","cache","nameList","includesSubNamePath","getFieldsMap","name","get","INVALIDATE_NAME_PATH","flatMap","fields","getAsPrefix","filterFunc","warningUnhooked","mergedNameList","mergedFilterFunc","Array","isArray","getFieldEntitiesForNamePathList","filteredNameList","listNamePaths","_entity$isList","isList","call","push","meta","getMeta","mergedValues","index","errors","getErrors","warnings","getWarnings","fieldError","_len","args","_key","arg0","arg1","namePathList","isAllFieldsTouched","every","some","shortNamePath","fieldNamePath","nameUnit","i","update","list","isNamePathListTouched","entities","namePathListEntities","_ref2","value","testField","info","initialValue","props","records","Set","add","resetWithFields","formInitialValue","concat","join","size","originValue","isListField","skipExist","requiredFieldEntities","r","prevStore","resetWithFieldInitialValue","notifyObservers","type","notifyWatch","fieldData","data","_objectWithoutProperties","_excluded","_objectSpread","Object","defineProperty","prevValue","fieldPreserve","mergedPreserve","source","subNamePath","item","defaultValue","triggerDependenciesUpdate","action","updateValue","triggerName","mergedInfo","_ref3","onStoreChange","childrenFields","getDependencyChildrenFields","relatedFields","onValuesChange","fieldEntity","changedValues","allValues","mergedAllValues","prepareArray","current","triggerOnFieldsChange","touched","rootNamePath","children","dependencies2fields","dependencies","dependency","dependencyNamePath","fillChildren","has","isFieldDirty","filedErrors","onFieldsChange","_ref4","changedFields","_ref5","fieldName","arg2","options","provideNameList","finalValueNamePathList","promiseList","TMP_SPLIT","String","Date","now","validateNamePathList","recursive","dirty","rules","promise","validateRules","then","catch","ruleErrors","_ruleErrors$forEach","mergedErrors","mergedWarnings","_ref6","rule","warningOnly","Promise","reject","summaryPromise","lastValidatePromise","results","resultNamePathList","_ref7","returnPromise","resolve","_errorList$","errorList","result","errorMessage","message","values","errorFields","outOfDate","e","triggerNamePathList","onFinish","err","console","error","onFinishFailed","useForm","form","formRef","useRef","forceUpdate","useState","forceReRender","formStore","getForm"],"sources":["/Users/ferncliffadmin/clawd/projects/thesalessherpa/src/client/node_modules/@rc-component/form/es/hooks/useForm.js"],"sourcesContent":["import { merge } from \"@rc-component/util/es/utils/set\";\nimport { mergeWith } from '@rc-component/util';\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { HOOK_MARK } from \"../FieldContext\";\nimport { allPromiseFinish } from \"../utils/asyncUtil\";\nimport { defaultValidateMessages } from \"../utils/messages\";\nimport NameMap from \"../utils/NameMap\";\nimport { cloneByNamePathList, containsNamePath, getNamePath, getValue, matchNamePath, setValue } from \"../utils/valueUtil\";\nimport WatcherCenter from \"./useNotifyWatch\";\nexport class FormStore {\n  formHooked = false;\n  forceRootUpdate;\n  subscribable = true;\n  store = {};\n  fieldEntities = [];\n  initialValues = {};\n  callbacks = {};\n  validateMessages = null;\n  preserve = null;\n  lastValidatePromise = null;\n  watcherCenter = new WatcherCenter(this);\n  constructor(forceRootUpdate) {\n    this.forceRootUpdate = forceRootUpdate;\n  }\n  getForm = () => ({\n    getFieldValue: this.getFieldValue,\n    getFieldsValue: this.getFieldsValue,\n    getFieldError: this.getFieldError,\n    getFieldWarning: this.getFieldWarning,\n    getFieldsError: this.getFieldsError,\n    isFieldsTouched: this.isFieldsTouched,\n    isFieldTouched: this.isFieldTouched,\n    isFieldValidating: this.isFieldValidating,\n    isFieldsValidating: this.isFieldsValidating,\n    resetFields: this.resetFields,\n    setFields: this.setFields,\n    setFieldValue: this.setFieldValue,\n    setFieldsValue: this.setFieldsValue,\n    validateFields: this.validateFields,\n    submit: this.submit,\n    _init: true,\n    getInternalHooks: this.getInternalHooks\n  });\n\n  // ======================== Internal Hooks ========================\n  getInternalHooks = key => {\n    if (key === HOOK_MARK) {\n      this.formHooked = true;\n      return {\n        dispatch: this.dispatch,\n        initEntityValue: this.initEntityValue,\n        registerField: this.registerField,\n        useSubscribe: this.useSubscribe,\n        setInitialValues: this.setInitialValues,\n        destroyForm: this.destroyForm,\n        setCallbacks: this.setCallbacks,\n        setValidateMessages: this.setValidateMessages,\n        getFields: this.getFields,\n        setPreserve: this.setPreserve,\n        getInitialValue: this.getInitialValue,\n        registerWatch: this.registerWatch\n      };\n    }\n    warning(false, '`getInternalHooks` is internal usage. Should not call directly.');\n    return null;\n  };\n  useSubscribe = subscribable => {\n    this.subscribable = subscribable;\n  };\n\n  /**\n   * Record prev Form unmount fieldEntities which config preserve false.\n   * This need to be refill with initialValues instead of store value.\n   */\n  prevWithoutPreserves = null;\n\n  /**\n   * First time `setInitialValues` should update store with initial value\n   */\n  setInitialValues = (initialValues, init) => {\n    this.initialValues = initialValues || {};\n    if (init) {\n      let nextStore = merge(initialValues, this.store);\n\n      // We will take consider prev form unmount fields.\n      // When the field is not `preserve`, we need fill this with initialValues instead of store.\n      // eslint-disable-next-line array-callback-return\n      this.prevWithoutPreserves?.map(({\n        key: namePath\n      }) => {\n        nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));\n      });\n      this.prevWithoutPreserves = null;\n      this.updateStore(nextStore);\n    }\n  };\n  destroyForm = clearOnDestroy => {\n    if (clearOnDestroy) {\n      // destroy form reset store\n      this.updateStore({});\n    } else {\n      // Fill preserve fields\n      const prevWithoutPreserves = new NameMap();\n      this.getFieldEntities(true).forEach(entity => {\n        if (!this.isMergedPreserve(entity.isPreserve())) {\n          prevWithoutPreserves.set(entity.getNamePath(), true);\n        }\n      });\n      this.prevWithoutPreserves = prevWithoutPreserves;\n    }\n  };\n  getInitialValue = namePath => {\n    const initValue = getValue(this.initialValues, namePath);\n\n    // Not cloneDeep when without `namePath`\n    return namePath.length ? merge(initValue) : initValue;\n  };\n  setCallbacks = callbacks => {\n    this.callbacks = callbacks;\n  };\n  setValidateMessages = validateMessages => {\n    this.validateMessages = validateMessages;\n  };\n  setPreserve = preserve => {\n    this.preserve = preserve;\n  };\n\n  // ============================= Watch ============================\n  registerWatch = callback => {\n    return this.watcherCenter.register(callback);\n  };\n  notifyWatch = (namePath = []) => {\n    this.watcherCenter.notify(namePath);\n  };\n\n  // ========================== Dev Warning =========================\n  timeoutId = null;\n  warningUnhooked = () => {\n    if (process.env.NODE_ENV !== 'production' && !this.timeoutId && typeof window !== 'undefined') {\n      this.timeoutId = setTimeout(() => {\n        this.timeoutId = null;\n        if (!this.formHooked) {\n          warning(false, 'Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?');\n        }\n      });\n    }\n  };\n\n  // ============================ Store =============================\n  updateStore = nextStore => {\n    this.store = nextStore;\n  };\n\n  // ============================ Fields ============================\n  /**\n   * Get registered field entities.\n   * @param pure Only return field which has a `name`. Default: false\n   */\n  getFieldEntities = (pure = false) => {\n    if (!pure) {\n      return this.fieldEntities;\n    }\n    return this.fieldEntities.filter(field => field.getNamePath().length);\n  };\n\n  /**\n   * Get a map of registered field entities with their name path as the key.\n   * @param pure Only include fields which have a `name`. Default: false\n   * @returns A NameMap containing field entities indexed by their name paths\n   */\n  getFieldsMap = (pure = false) => {\n    const cache = new NameMap();\n    this.getFieldEntities(pure).forEach(field => {\n      const namePath = field.getNamePath();\n      cache.set(namePath, field);\n    });\n    return cache;\n  };\n\n  /**\n   * Get field entities based on a list of name paths.\n   * @param nameList - Array of name paths to search for. If not provided, returns all field entities with names.\n   * @param includesSubNamePath - Whether to include fields that have the given name path as a prefix.\n   */\n  getFieldEntitiesForNamePathList = (nameList, includesSubNamePath = false) => {\n    if (!nameList) {\n      return this.getFieldEntities(true);\n    }\n    const cache = this.getFieldsMap(true);\n    if (!includesSubNamePath) {\n      return nameList.map(name => {\n        const namePath = getNamePath(name);\n        return cache.get(namePath) || {\n          INVALIDATE_NAME_PATH: getNamePath(name)\n        };\n      });\n    }\n    return nameList.flatMap(name => {\n      const namePath = getNamePath(name);\n      const fields = cache.getAsPrefix(namePath);\n      if (fields.length) {\n        return fields;\n      }\n      return [{\n        INVALIDATE_NAME_PATH: namePath\n      }];\n    });\n  };\n  getFieldsValue = (nameList, filterFunc) => {\n    this.warningUnhooked();\n\n    // Fill args\n    let mergedNameList;\n    let mergedFilterFunc;\n    if (nameList === true || Array.isArray(nameList)) {\n      mergedNameList = nameList;\n      mergedFilterFunc = filterFunc;\n    } else if (nameList && typeof nameList === 'object') {\n      mergedFilterFunc = nameList.filter;\n    }\n    if (mergedNameList === true && !mergedFilterFunc) {\n      return this.store;\n    }\n    const fieldEntities = this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null, true);\n    const filteredNameList = [];\n    const listNamePaths = [];\n    fieldEntities.forEach(entity => {\n      const namePath = entity.INVALIDATE_NAME_PATH || entity.getNamePath();\n\n      // Ignore when it's a list item and not specific the namePath,\n      // since parent field is already take in count\n      if (entity.isList?.()) {\n        listNamePaths.push(namePath);\n        return;\n      }\n      if (!mergedFilterFunc) {\n        filteredNameList.push(namePath);\n      } else {\n        const meta = 'getMeta' in entity ? entity.getMeta() : null;\n        if (mergedFilterFunc(meta)) {\n          filteredNameList.push(namePath);\n        }\n      }\n    });\n    let mergedValues = cloneByNamePathList(this.store, filteredNameList.map(getNamePath));\n\n    // We need fill the list as [] if Form.List is empty\n    listNamePaths.forEach(namePath => {\n      if (!getValue(mergedValues, namePath)) {\n        mergedValues = setValue(mergedValues, namePath, []);\n      }\n    });\n    return mergedValues;\n  };\n  getFieldValue = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    return getValue(this.store, namePath);\n  };\n  getFieldsError = nameList => {\n    this.warningUnhooked();\n    const fieldEntities = this.getFieldEntitiesForNamePathList(nameList);\n    return fieldEntities.map((entity, index) => {\n      if (entity && !entity.INVALIDATE_NAME_PATH) {\n        return {\n          name: entity.getNamePath(),\n          errors: entity.getErrors(),\n          warnings: entity.getWarnings()\n        };\n      }\n      return {\n        name: getNamePath(nameList[index]),\n        errors: [],\n        warnings: []\n      };\n    });\n  };\n  getFieldError = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    const fieldError = this.getFieldsError([namePath])[0];\n    return fieldError.errors;\n  };\n  getFieldWarning = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    const fieldError = this.getFieldsError([namePath])[0];\n    return fieldError.warnings;\n  };\n  isFieldsTouched = (...args) => {\n    this.warningUnhooked();\n    const [arg0, arg1] = args;\n    let namePathList;\n    let isAllFieldsTouched = false;\n    if (args.length === 0) {\n      namePathList = null;\n    } else if (args.length === 1) {\n      if (Array.isArray(arg0)) {\n        namePathList = arg0.map(getNamePath);\n        isAllFieldsTouched = false;\n      } else {\n        namePathList = null;\n        isAllFieldsTouched = arg0;\n      }\n    } else {\n      namePathList = arg0.map(getNamePath);\n      isAllFieldsTouched = arg1;\n    }\n    const fieldEntities = this.getFieldEntities(true);\n    const isFieldTouched = field => field.isFieldTouched();\n\n    // ===== Will get fully compare when not config namePathList =====\n    if (!namePathList) {\n      return isAllFieldsTouched ? fieldEntities.every(entity => isFieldTouched(entity) || entity.isList()) : fieldEntities.some(isFieldTouched);\n    }\n\n    // Generate a nest tree for validate\n    const map = new NameMap();\n    namePathList.forEach(shortNamePath => {\n      map.set(shortNamePath, []);\n    });\n    fieldEntities.forEach(field => {\n      const fieldNamePath = field.getNamePath();\n\n      // Find matched entity and put into list\n      namePathList.forEach(shortNamePath => {\n        if (shortNamePath.every((nameUnit, i) => fieldNamePath[i] === nameUnit)) {\n          map.update(shortNamePath, list => [...list, field]);\n        }\n      });\n    });\n\n    // Check if NameMap value is touched\n    const isNamePathListTouched = entities => entities.some(isFieldTouched);\n    const namePathListEntities = map.map(({\n      value\n    }) => value);\n    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);\n  };\n  isFieldTouched = name => {\n    this.warningUnhooked();\n    return this.isFieldsTouched([name]);\n  };\n  isFieldsValidating = nameList => {\n    this.warningUnhooked();\n    const fieldEntities = this.getFieldEntities();\n    if (!nameList) {\n      return fieldEntities.some(testField => testField.isFieldValidating());\n    }\n    const namePathList = nameList.map(getNamePath);\n    return fieldEntities.some(testField => {\n      const fieldNamePath = testField.getNamePath();\n      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();\n    });\n  };\n  isFieldValidating = name => {\n    this.warningUnhooked();\n    return this.isFieldsValidating([name]);\n  };\n\n  /**\n   * Reset Field with field `initialValue` prop.\n   * Can pass `entities` or `namePathList` or just nothing.\n   */\n  resetWithFieldInitialValue = (info = {}) => {\n    // Create cache\n    const cache = new NameMap();\n    const fieldEntities = this.getFieldEntities(true);\n    fieldEntities.forEach(field => {\n      const {\n        initialValue\n      } = field.props;\n      const namePath = field.getNamePath();\n\n      // Record only if has `initialValue`\n      if (initialValue !== undefined) {\n        const records = cache.get(namePath) || new Set();\n        records.add({\n          entity: field,\n          value: initialValue\n        });\n        cache.set(namePath, records);\n      }\n    });\n\n    // Reset\n    const resetWithFields = entities => {\n      entities.forEach(field => {\n        const {\n          initialValue\n        } = field.props;\n        if (initialValue !== undefined) {\n          const namePath = field.getNamePath();\n          const formInitialValue = this.getInitialValue(namePath);\n          if (formInitialValue !== undefined) {\n            // Warning if conflict with form initialValues and do not modify value\n            warning(false, `Form already set 'initialValues' with path '${namePath.join('.')}'. Field can not overwrite it.`);\n          } else {\n            const records = cache.get(namePath);\n            if (records && records.size > 1) {\n              // Warning if multiple field set `initialValue`and do not modify value\n              warning(false, `Multiple Field with path '${namePath.join('.')}' set 'initialValue'. Can not decide which one to pick.`);\n            } else if (records) {\n              const originValue = this.getFieldValue(namePath);\n              const isListField = field.isListField();\n\n              // Set `initialValue`\n              if (!isListField && (!info.skipExist || originValue === undefined)) {\n                this.updateStore(setValue(this.store, namePath, [...records][0].value));\n              }\n            }\n          }\n        }\n      });\n    };\n    let requiredFieldEntities;\n    if (info.entities) {\n      requiredFieldEntities = info.entities;\n    } else if (info.namePathList) {\n      requiredFieldEntities = [];\n      info.namePathList.forEach(namePath => {\n        const records = cache.get(namePath);\n        if (records) {\n          requiredFieldEntities.push(...[...records].map(r => r.entity));\n        }\n      });\n    } else {\n      requiredFieldEntities = fieldEntities;\n    }\n    resetWithFields(requiredFieldEntities);\n  };\n  resetFields = nameList => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    if (!nameList) {\n      this.updateStore(merge(this.initialValues));\n      this.resetWithFieldInitialValue();\n      this.notifyObservers(prevStore, null, {\n        type: 'reset'\n      });\n      this.notifyWatch();\n      return;\n    }\n\n    // Reset by `nameList`\n    const namePathList = nameList.map(getNamePath);\n    namePathList.forEach(namePath => {\n      const initialValue = this.getInitialValue(namePath);\n      this.updateStore(setValue(this.store, namePath, initialValue));\n    });\n    this.resetWithFieldInitialValue({\n      namePathList\n    });\n    this.notifyObservers(prevStore, namePathList, {\n      type: 'reset'\n    });\n    this.notifyWatch(namePathList);\n  };\n  setFields = fields => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    const namePathList = [];\n    fields.forEach(fieldData => {\n      const {\n        name,\n        ...data\n      } = fieldData;\n      const namePath = getNamePath(name);\n      namePathList.push(namePath);\n\n      // Value\n      if ('value' in data) {\n        this.updateStore(setValue(this.store, namePath, data.value));\n      }\n      this.notifyObservers(prevStore, [namePath], {\n        type: 'setField',\n        data: fieldData\n      });\n    });\n    this.notifyWatch(namePathList);\n  };\n  getFields = () => {\n    const entities = this.getFieldEntities(true);\n    const fields = entities.map(field => {\n      const namePath = field.getNamePath();\n      const meta = field.getMeta();\n      const fieldData = {\n        ...meta,\n        name: namePath,\n        value: this.getFieldValue(namePath)\n      };\n      Object.defineProperty(fieldData, 'originRCField', {\n        value: true\n      });\n      return fieldData;\n    });\n    return fields;\n  };\n\n  // =========================== Observer ===========================\n  /**\n   * This only trigger when a field is on constructor to avoid we get initialValue too late\n   */\n  initEntityValue = entity => {\n    const {\n      initialValue\n    } = entity.props;\n    if (initialValue !== undefined) {\n      const namePath = entity.getNamePath();\n      const prevValue = getValue(this.store, namePath);\n      if (prevValue === undefined) {\n        this.updateStore(setValue(this.store, namePath, initialValue));\n      }\n    }\n  };\n  isMergedPreserve = fieldPreserve => {\n    const mergedPreserve = fieldPreserve !== undefined ? fieldPreserve : this.preserve;\n    return mergedPreserve ?? true;\n  };\n  registerField = entity => {\n    this.fieldEntities.push(entity);\n    const namePath = entity.getNamePath();\n    this.notifyWatch([namePath]);\n\n    // Set initial values\n    if (entity.props.initialValue !== undefined) {\n      const prevStore = this.store;\n      this.resetWithFieldInitialValue({\n        entities: [entity],\n        skipExist: true\n      });\n      this.notifyObservers(prevStore, [entity.getNamePath()], {\n        type: 'valueUpdate',\n        source: 'internal'\n      });\n    }\n\n    // un-register field callback\n    return (isListField, preserve, subNamePath = []) => {\n      this.fieldEntities = this.fieldEntities.filter(item => item !== entity);\n\n      // Clean up store value if not preserve\n      if (!this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {\n        const defaultValue = isListField ? undefined : this.getInitialValue(namePath);\n        if (namePath.length && this.getFieldValue(namePath) !== defaultValue && this.fieldEntities.every(field =>\n        // Only reset when no namePath exist\n        !matchNamePath(field.getNamePath(), namePath))) {\n          const prevStore = this.store;\n          this.updateStore(setValue(prevStore, namePath, defaultValue, true));\n\n          // Notify that field is unmount\n          this.notifyObservers(prevStore, [namePath], {\n            type: 'remove'\n          });\n\n          // Dependencies update\n          this.triggerDependenciesUpdate(prevStore, namePath);\n        }\n      }\n      this.notifyWatch([namePath]);\n    };\n  };\n  dispatch = action => {\n    switch (action.type) {\n      case 'updateValue':\n        {\n          const {\n            namePath,\n            value\n          } = action;\n          this.updateValue(namePath, value);\n          break;\n        }\n      case 'validateField':\n        {\n          const {\n            namePath,\n            triggerName\n          } = action;\n          this.validateFields([namePath], {\n            triggerName\n          });\n          break;\n        }\n      default:\n      // Currently we don't have other action. Do nothing.\n    }\n  };\n  notifyObservers = (prevStore, namePathList, info) => {\n    if (this.subscribable) {\n      const mergedInfo = {\n        ...info,\n        store: this.getFieldsValue(true)\n      };\n      this.getFieldEntities().forEach(({\n        onStoreChange\n      }) => {\n        onStoreChange(prevStore, namePathList, mergedInfo);\n      });\n    } else {\n      this.forceRootUpdate();\n    }\n  };\n\n  /**\n   * Notify dependencies children with parent update\n   * We need delay to trigger validate in case Field is under render props\n   */\n  triggerDependenciesUpdate = (prevStore, namePath) => {\n    const childrenFields = this.getDependencyChildrenFields(namePath);\n    if (childrenFields.length) {\n      this.validateFields(childrenFields);\n    }\n    this.notifyObservers(prevStore, childrenFields, {\n      type: 'dependenciesUpdate',\n      relatedFields: [namePath, ...childrenFields]\n    });\n    return childrenFields;\n  };\n  updateValue = (name, value) => {\n    const namePath = getNamePath(name);\n    const prevStore = this.store;\n    this.updateStore(setValue(this.store, namePath, value));\n    this.notifyObservers(prevStore, [namePath], {\n      type: 'valueUpdate',\n      source: 'internal'\n    });\n    this.notifyWatch([namePath]);\n\n    // Dependencies update\n    const childrenFields = this.triggerDependenciesUpdate(prevStore, namePath);\n\n    // trigger callback function\n    const {\n      onValuesChange\n    } = this.callbacks;\n    if (onValuesChange) {\n      const fieldEntity = this.getFieldsMap(true).get(namePath);\n      const changedValues = cloneByNamePathList(this.store, [namePath]);\n      const allValues = this.getFieldsValue();\n      // Merge changedValues into allValues to ensure allValues contains the latest changes\n      const mergedAllValues = mergeWith([allValues, changedValues], {\n        // When value is array, it means trigger by Form.List which should replace directly\n        prepareArray: current => fieldEntity?.isList() ? [] : [...(current || [])]\n      });\n      onValuesChange(changedValues, mergedAllValues);\n    }\n    this.triggerOnFieldsChange([namePath, ...childrenFields]);\n  };\n\n  // Let all child Field get update.\n  setFieldsValue = store => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    if (store) {\n      const nextStore = merge(this.store, store);\n      this.updateStore(nextStore);\n    }\n    this.notifyObservers(prevStore, null, {\n      type: 'valueUpdate',\n      source: 'external'\n    });\n    this.notifyWatch();\n  };\n  setFieldValue = (name, value) => {\n    this.setFields([{\n      name,\n      value,\n      errors: [],\n      warnings: [],\n      touched: true\n    }]);\n  };\n  getDependencyChildrenFields = rootNamePath => {\n    const children = new Set();\n    const childrenFields = [];\n    const dependencies2fields = new NameMap();\n\n    /**\n     * Generate maps\n     * Can use cache to save perf if user report performance issue with this\n     */\n    this.getFieldEntities().forEach(field => {\n      const {\n        dependencies\n      } = field.props;\n      (dependencies || []).forEach(dependency => {\n        const dependencyNamePath = getNamePath(dependency);\n        dependencies2fields.update(dependencyNamePath, (fields = new Set()) => {\n          fields.add(field);\n          return fields;\n        });\n      });\n    });\n    const fillChildren = namePath => {\n      const fields = dependencies2fields.get(namePath) || new Set();\n      fields.forEach(field => {\n        if (!children.has(field)) {\n          children.add(field);\n          const fieldNamePath = field.getNamePath();\n          if (field.isFieldDirty() && fieldNamePath.length) {\n            childrenFields.push(fieldNamePath);\n            fillChildren(fieldNamePath);\n          }\n        }\n      });\n    };\n    fillChildren(rootNamePath);\n    return childrenFields;\n  };\n  triggerOnFieldsChange = (namePathList, filedErrors) => {\n    const {\n      onFieldsChange\n    } = this.callbacks;\n    if (onFieldsChange) {\n      const fields = this.getFields();\n\n      /**\n       * Fill errors since `fields` may be replaced by controlled fields\n       */\n      if (filedErrors) {\n        const cache = new NameMap();\n        filedErrors.forEach(({\n          name,\n          errors\n        }) => {\n          cache.set(name, errors);\n        });\n        fields.forEach(field => {\n          // eslint-disable-next-line no-param-reassign\n          field.errors = cache.get(field.name) || field.errors;\n        });\n      }\n      const changedFields = fields.filter(({\n        name: fieldName\n      }) => containsNamePath(namePathList, fieldName));\n      if (changedFields.length) {\n        onFieldsChange(changedFields, fields);\n      }\n    }\n  };\n\n  // =========================== Validate ===========================\n  validateFields = (arg1, arg2) => {\n    this.warningUnhooked();\n    let nameList;\n    let options;\n    if (Array.isArray(arg1) || typeof arg1 === 'string' || typeof arg2 === 'string') {\n      nameList = arg1;\n      options = arg2;\n    } else {\n      options = arg1;\n    }\n    const provideNameList = !!nameList;\n    const namePathList = provideNameList ? nameList.map(getNamePath) : [];\n    // Same namePathList, but does not include Form.List name\n    const finalValueNamePathList = [...namePathList];\n\n    // Collect result in promise list\n    const promiseList = [];\n\n    // We temp save the path which need trigger for `onFieldsChange`\n    const TMP_SPLIT = String(Date.now());\n    const validateNamePathList = new Set();\n    const {\n      recursive,\n      dirty\n    } = options || {};\n    this.getFieldEntities(true).forEach(field => {\n      const fieldNamePath = field.getNamePath();\n\n      // Add field if not provide `nameList`\n      if (!provideNameList) {\n        if (\n        // If is field, pass directly\n        !field.isList() ||\n        // If is list, do not add if already exist sub field in the namePathList\n        !namePathList.some(name => matchNamePath(name, fieldNamePath, true))) {\n          finalValueNamePathList.push(fieldNamePath);\n        }\n        namePathList.push(fieldNamePath);\n      }\n\n      // Skip if without rule\n      if (!field.props.rules || !field.props.rules.length) {\n        return;\n      }\n\n      // Skip if only validate dirty field\n      if (dirty && !field.isFieldDirty()) {\n        return;\n      }\n      validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));\n\n      // Add field validate rule in to promise list\n      if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {\n        const promise = field.validateRules({\n          validateMessages: {\n            ...defaultValidateMessages,\n            ...this.validateMessages\n          },\n          ...options\n        });\n\n        // Wrap promise with field\n        promiseList.push(promise.then(() => ({\n          name: fieldNamePath,\n          errors: [],\n          warnings: []\n        })).catch(ruleErrors => {\n          const mergedErrors = [];\n          const mergedWarnings = [];\n          ruleErrors.forEach?.(({\n            rule: {\n              warningOnly\n            },\n            errors\n          }) => {\n            if (warningOnly) {\n              mergedWarnings.push(...errors);\n            } else {\n              mergedErrors.push(...errors);\n            }\n          });\n          if (mergedErrors.length) {\n            return Promise.reject({\n              name: fieldNamePath,\n              errors: mergedErrors,\n              warnings: mergedWarnings\n            });\n          }\n          return {\n            name: fieldNamePath,\n            errors: mergedErrors,\n            warnings: mergedWarnings\n          };\n        }));\n      }\n    });\n    const summaryPromise = allPromiseFinish(promiseList);\n    this.lastValidatePromise = summaryPromise;\n\n    // Notify fields with rule that validate has finished and need update\n    summaryPromise.catch(results => results).then(results => {\n      const resultNamePathList = results.map(({\n        name\n      }) => name);\n      this.notifyObservers(this.store, resultNamePathList, {\n        type: 'validateFinish'\n      });\n      this.triggerOnFieldsChange(resultNamePathList, results);\n    });\n    const returnPromise = summaryPromise.then(() => {\n      if (this.lastValidatePromise === summaryPromise) {\n        return Promise.resolve(this.getFieldsValue(finalValueNamePathList));\n      }\n      return Promise.reject([]);\n    }).catch(results => {\n      const errorList = results.filter(result => result && result.errors.length);\n      const errorMessage = errorList[0]?.errors?.[0];\n      return Promise.reject({\n        message: errorMessage,\n        values: this.getFieldsValue(namePathList),\n        errorFields: errorList,\n        outOfDate: this.lastValidatePromise !== summaryPromise\n      });\n    });\n\n    // Do not throw in console\n    returnPromise.catch(e => e);\n\n    // `validating` changed. Trigger `onFieldsChange`\n    const triggerNamePathList = namePathList.filter(namePath => validateNamePathList.has(namePath.join(TMP_SPLIT)));\n    this.triggerOnFieldsChange(triggerNamePathList);\n    return returnPromise;\n  };\n\n  // ============================ Submit ============================\n  submit = () => {\n    this.warningUnhooked();\n    this.validateFields().then(values => {\n      const {\n        onFinish\n      } = this.callbacks;\n      if (onFinish) {\n        try {\n          onFinish(values);\n        } catch (err) {\n          // Should print error if user `onFinish` callback failed\n          console.error(err);\n        }\n      }\n    }).catch(e => {\n      const {\n        onFinishFailed\n      } = this.callbacks;\n      if (onFinishFailed) {\n        onFinishFailed(e);\n      }\n    });\n  };\n}\nfunction useForm(form) {\n  const formRef = React.useRef(null);\n  const [, forceUpdate] = React.useState({});\n\n  // Create singleton FormStore\n  if (!formRef.current) {\n    if (form) {\n      formRef.current = form;\n    } else {\n      // Create a new FormStore if not provided\n      const forceReRender = () => {\n        forceUpdate({});\n      };\n      const formStore = new FormStore(forceReRender);\n      formRef.current = formStore.getForm();\n    }\n  }\n  return [formRef.current];\n}\nexport default useForm;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}